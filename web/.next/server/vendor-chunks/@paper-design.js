"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@paper-design";
exports.ids = ["vendor-chunks/@paper-design"];
exports.modules = {

/***/ "(ssr)/./node_modules/@paper-design/shaders-react/dist/color-props-are-equal.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@paper-design/shaders-react/dist/color-props-are-equal.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   colorPropsAreEqual: () => (/* binding */ colorPropsAreEqual)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nfunction colorPropsAreEqual(prevProps, nextProps) {\n  for (const key in prevProps) {\n    if (key === \"colors\") {\n      const prevIsArray = Array.isArray(prevProps.colors);\n      const nextIsArray = Array.isArray(nextProps.colors);\n      if (!prevIsArray || !nextIsArray) {\n        if (Object.is(prevProps.colors, nextProps.colors) === false) {\n          return false;\n        }\n        continue;\n      }\n      if (prevProps.colors?.length !== nextProps.colors?.length) {\n        return false;\n      }\n      if (!prevProps.colors?.every((color, index) => color === nextProps.colors?.[index])) {\n        return false;\n      }\n      continue;\n    }\n    if (Object.is(prevProps[key], nextProps[key]) === false) {\n      return false;\n    }\n  }\n  return true;\n}\n\n//# sourceMappingURL=color-props-are-equal.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3QvY29sb3ItcHJvcHMtYXJlLWVxdWFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9pbXJhbm1vaGFtbWVkL2Rlc2lnbi13aXRoLWNsYXVkZS93ZWIvbm9kZV9tb2R1bGVzL0BwYXBlci1kZXNpZ24vc2hhZGVycy1yZWFjdC9kaXN0L2NvbG9yLXByb3BzLWFyZS1lcXVhbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogICAgICAgICAgICAgICAgICAgIFBhcGVyIFNoYWRlcnMgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXBlci1kZXNpZ24vc2hhZGVycyAgICAgICAqXG4gKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKi9cblxuZnVuY3Rpb24gY29sb3JQcm9wc0FyZUVxdWFsKHByZXZQcm9wcywgbmV4dFByb3BzKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIHByZXZQcm9wcykge1xuICAgIGlmIChrZXkgPT09IFwiY29sb3JzXCIpIHtcbiAgICAgIGNvbnN0IHByZXZJc0FycmF5ID0gQXJyYXkuaXNBcnJheShwcmV2UHJvcHMuY29sb3JzKTtcbiAgICAgIGNvbnN0IG5leHRJc0FycmF5ID0gQXJyYXkuaXNBcnJheShuZXh0UHJvcHMuY29sb3JzKTtcbiAgICAgIGlmICghcHJldklzQXJyYXkgfHwgIW5leHRJc0FycmF5KSB7XG4gICAgICAgIGlmIChPYmplY3QuaXMocHJldlByb3BzLmNvbG9ycywgbmV4dFByb3BzLmNvbG9ycykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByZXZQcm9wcy5jb2xvcnM/Lmxlbmd0aCAhPT0gbmV4dFByb3BzLmNvbG9ycz8ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghcHJldlByb3BzLmNvbG9ycz8uZXZlcnkoKGNvbG9yLCBpbmRleCkgPT4gY29sb3IgPT09IG5leHRQcm9wcy5jb2xvcnM/LltpbmRleF0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmlzKHByZXZQcm9wc1trZXldLCBuZXh0UHJvcHNba2V5XSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZXhwb3J0IHtcbiAgY29sb3JQcm9wc0FyZUVxdWFsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29sb3ItcHJvcHMtYXJlLWVxdWFsLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders-react/dist/color-props-are-equal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders-react/dist/shader-mount.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@paper-design/shaders-react/dist/shader-mount.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShaderMount: () => (/* binding */ ShaderMount)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @paper-design/shaders */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shader-mount.js\");\n/* harmony import */ var _use_merge_refs_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./use-merge-refs.js */ \"(ssr)/./node_modules/@paper-design/shaders-react/dist/use-merge-refs.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */ /* __next_internal_client_entry_do_not_use__ ShaderMount auto */ \n\n\n\nasync function processUniforms(uniformsProp) {\n    const processedUniforms = {};\n    const imageLoadPromises = [];\n    const isValidUrl = (url)=>{\n        try {\n            if (url.startsWith(\"/\")) return true;\n            new URL(url);\n            return true;\n        } catch  {\n            return false;\n        }\n    };\n    const isExternalUrl = (url)=>{\n        try {\n            if (url.startsWith(\"/\")) return false;\n            const urlObject = new URL(url, window.location.origin);\n            return urlObject.origin !== window.location.origin;\n        } catch  {\n            return false;\n        }\n    };\n    Object.entries(uniformsProp).forEach(([key, value])=>{\n        if (typeof value === \"string\") {\n            if (!isValidUrl(value)) {\n                console.warn(`Uniform \"${key}\" has invalid URL \"${value}\". Skipping image loading.`);\n                return;\n            }\n            const imagePromise = new Promise((resolve, reject)=>{\n                const img = new Image();\n                if (isExternalUrl(value)) {\n                    img.crossOrigin = \"anonymous\";\n                }\n                img.onload = ()=>{\n                    processedUniforms[key] = img;\n                    resolve();\n                };\n                img.onerror = ()=>{\n                    console.error(`Could not set uniforms. Failed to load image at ${value}`);\n                    reject();\n                };\n                img.src = value;\n            });\n            imageLoadPromises.push(imagePromise);\n        } else {\n            processedUniforms[key] = value;\n        }\n    });\n    await Promise.all(imageLoadPromises);\n    return processedUniforms;\n}\nconst ShaderMount = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function ShaderMountImpl({ fragmentShader, uniforms: uniformsProp, webGlContextAttributes, speed = 0, frame = 0, minPixelRatio, maxPixelCount, ...divProps }, forwardedRef) {\n    const [isInitialized, setIsInitialized] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const divRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const shaderMountRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"ShaderMount.ShaderMountImpl.useEffect\": ()=>{\n            const initShader = {\n                \"ShaderMount.ShaderMountImpl.useEffect.initShader\": async ()=>{\n                    const uniforms = await processUniforms(uniformsProp);\n                    if (divRef.current && !shaderMountRef.current) {\n                        shaderMountRef.current = new _paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.ShaderMount(divRef.current, fragmentShader, uniforms, webGlContextAttributes, speed, frame, minPixelRatio, maxPixelCount);\n                        setIsInitialized(true);\n                    }\n                }\n            }[\"ShaderMount.ShaderMountImpl.useEffect.initShader\"];\n            initShader();\n            return ({\n                \"ShaderMount.ShaderMountImpl.useEffect\": ()=>{\n                    shaderMountRef.current?.dispose();\n                    shaderMountRef.current = null;\n                }\n            })[\"ShaderMount.ShaderMountImpl.useEffect\"];\n        }\n    }[\"ShaderMount.ShaderMountImpl.useEffect\"], [\n        fragmentShader,\n        webGlContextAttributes\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"ShaderMount.ShaderMountImpl.useEffect\": ()=>{\n            let isStale = false;\n            const updateUniforms = {\n                \"ShaderMount.ShaderMountImpl.useEffect.updateUniforms\": async ()=>{\n                    const uniforms = await processUniforms(uniformsProp);\n                    if (!isStale) {\n                        shaderMountRef.current?.setUniforms(uniforms);\n                    }\n                }\n            }[\"ShaderMount.ShaderMountImpl.useEffect.updateUniforms\"];\n            updateUniforms();\n            return ({\n                \"ShaderMount.ShaderMountImpl.useEffect\": ()=>{\n                    isStale = true;\n                }\n            })[\"ShaderMount.ShaderMountImpl.useEffect\"];\n        }\n    }[\"ShaderMount.ShaderMountImpl.useEffect\"], [\n        uniformsProp,\n        isInitialized\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"ShaderMount.ShaderMountImpl.useEffect\": ()=>{\n            shaderMountRef.current?.setSpeed(speed);\n        }\n    }[\"ShaderMount.ShaderMountImpl.useEffect\"], [\n        speed,\n        isInitialized\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"ShaderMount.ShaderMountImpl.useEffect\": ()=>{\n            shaderMountRef.current?.setMaxPixelCount(maxPixelCount);\n        }\n    }[\"ShaderMount.ShaderMountImpl.useEffect\"], [\n        maxPixelCount,\n        isInitialized\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"ShaderMount.ShaderMountImpl.useEffect\": ()=>{\n            shaderMountRef.current?.setMinPixelRatio(minPixelRatio);\n        }\n    }[\"ShaderMount.ShaderMountImpl.useEffect\"], [\n        minPixelRatio,\n        isInitialized\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"ShaderMount.ShaderMountImpl.useEffect\": ()=>{\n            shaderMountRef.current?.setFrame(frame);\n        }\n    }[\"ShaderMount.ShaderMountImpl.useEffect\"], [\n        frame,\n        isInitialized\n    ]);\n    const mergedRef = (0,_use_merge_refs_js__WEBPACK_IMPORTED_MODULE_3__.useMergeRefs)([\n        divRef,\n        forwardedRef\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n        ref: mergedRef,\n        ...divProps\n    });\n});\nShaderMount.displayName = \"ShaderMount\";\n //# sourceMappingURL=shader-mount.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3Qvc2hhZGVyLW1vdW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OzJIQUV3RDtBQU1qRDtBQUNzQjtBQXFMbEI7QUF4SlgsZUFBZSxnQkFBZ0IsY0FBc0U7SUFDbkcsTUFBTSxvQkFBb0IsQ0FBQztJQUMzQixNQUFNLG9CQUFxQyxDQUFDO0lBRTVDLE1BQU0sYUFBYSxDQUFDO1FBQ2xCLElBQUk7WUFFRixJQUFJLElBQUksV0FBVyxHQUFHLEVBQUcsUUFBTztZQUVoQyxJQUFJLElBQUksR0FBRztZQUNYLE9BQU87UUFDVCxTQUFRO1lBQ04sT0FBTztRQUNUO0lBQ0Y7SUFFQSxNQUFNLGdCQUFnQixDQUFDO1FBQ3JCLElBQUk7WUFDRixJQUFJLElBQUksV0FBVyxHQUFHLEVBQUcsUUFBTztZQUNoQyxNQUFNLFlBQVksSUFBSSxJQUFJLEtBQUssT0FBTyxTQUFTLE1BQU07WUFDckQsT0FBTyxVQUFVLFdBQVcsT0FBTyxTQUFTO1FBQzlDLFNBQVE7WUFDTixPQUFPO1FBQ1Q7SUFDRjtJQUVBLE9BQU8sUUFBUSxZQUFZLEVBQUUsUUFBUSxDQUFDLENBQUMsS0FBSyxLQUFLO1FBQy9DLElBQUksT0FBTyxVQUFVLFVBQVU7WUFFN0IsSUFBSSxDQUFDLFdBQVcsS0FBSyxHQUFHO2dCQUN0QixRQUFRLEtBQUssWUFBWSxHQUFHLHNCQUFzQixLQUFLLDRCQUE0QjtnQkFDbkY7WUFDRjtZQUVBLE1BQU0sZUFBZSxJQUFJLFFBQWMsQ0FBQyxTQUFTO2dCQUMvQyxNQUFNLE1BQU0sSUFBSSxNQUFNO2dCQUN0QixJQUFJLGNBQWMsS0FBSyxHQUFHO29CQUN4QixJQUFJLGNBQWM7Z0JBQ3BCO2dCQUNBLElBQUksU0FBUztvQkFDWCxrQkFBa0IsR0FBRyxJQUFJO29CQUN6QixRQUFRO2dCQUNWO2dCQUNBLElBQUksVUFBVTtvQkFDWixRQUFRLE1BQU0sbURBQW1ELEtBQUssRUFBRTtvQkFDeEUsT0FBTztnQkFDVDtnQkFDQSxJQUFJLE1BQU07WUFDWixDQUFDO1lBQ0Qsa0JBQWtCLEtBQUssWUFBWTtRQUNyQyxPQUFPO1lBQ0wsa0JBQWtCLEdBQUcsSUFBSTtRQUMzQjtJQUNGLENBQUM7SUFFRCxNQUFNLFFBQVEsSUFBSSxpQkFBaUI7SUFDbkMsT0FBTztBQUNUO0FBTU8sTUFBTSw0QkFBMEMsaURBQVUsQ0FDL0QsU0FBUyxnQkFDUCxFQUNFLGdCQUNBLFVBQVUsY0FDVix3QkFDQSxRQUFRLEdBQ1IsUUFBUSxHQUNSLGVBQ0EsZUFDQSxHQUFHLFVBQ0wsRUFDQSxjQUNBO0lBQ0EsTUFBTSxDQUFDLGVBQWUsZ0JBQWdCLElBQUksK0NBQVEsQ0FBQyxLQUFLO0lBQ3hELE1BQU0sU0FBUyw2Q0FBTSxDQUFxQixJQUFJO0lBQzlDLE1BQU0saUJBQTZELDZDQUFNLENBQXFCLElBQUk7SUFHbEcsZ0RBQVM7aURBQUM7WUFDUixNQUFNO29FQUFhO29CQUNqQixNQUFNLFdBQVcsTUFBTSxnQkFBZ0IsWUFBWTtvQkFFbkQsSUFBSSxPQUFPLFdBQVcsQ0FBQyxlQUFlLFNBQVM7d0JBQzdDLGVBQWUsVUFBVSxJQUFJLDhEQUFrQixDQUM3QyxPQUFPLFNBQ1AsZ0JBQ0EsVUFDQSx3QkFDQSxPQUNBLE9BQ0EsZUFDQTt3QkFHRixpQkFBaUIsSUFBSTtvQkFDdkI7Z0JBQ0Y7O1lBRUEsV0FBVztZQUVYO3lEQUFPO29CQUNMLGVBQWUsU0FBUyxRQUFRO29CQUNoQyxlQUFlLFVBQVU7Z0JBQzNCOztRQUNGO2dEQUFHO1FBQUM7UUFBZ0Isc0JBQXNCO0tBQUM7SUFHM0MsZ0RBQVM7aURBQUM7WUFDUixJQUFJLFVBQVU7WUFFZCxNQUFNO3dFQUFpQjtvQkFDckIsTUFBTSxXQUFXLE1BQU0sZ0JBQWdCLFlBQVk7b0JBRW5ELElBQUksQ0FBQyxTQUFTO3dCQUdaLGVBQWUsU0FBUyxZQUFZLFFBQVE7b0JBQzlDO2dCQUNGOztZQUVBLGVBQWU7WUFFZjt5REFBTztvQkFDTCxVQUFVO2dCQUNaOztRQUNGO2dEQUFHO1FBQUM7UUFBYyxhQUFhO0tBQUM7SUFHaEMsZ0RBQVM7aURBQUM7WUFDUixlQUFlLFNBQVMsU0FBUyxLQUFLO1FBQ3hDO2dEQUFHO1FBQUM7UUFBTyxhQUFhO0tBQUM7SUFHekIsZ0RBQVM7aURBQUM7WUFDUixlQUFlLFNBQVMsaUJBQWlCLGFBQWE7UUFDeEQ7Z0RBQUc7UUFBQztRQUFlLGFBQWE7S0FBQztJQUdqQyxnREFBUztpREFBQztZQUNSLGVBQWUsU0FBUyxpQkFBaUIsYUFBYTtRQUN4RDtnREFBRztRQUFDO1FBQWUsYUFBYTtLQUFDO0lBR2pDLGdEQUFTO2lEQUFDO1lBQ1IsZUFBZSxTQUFTLFNBQVMsS0FBSztRQUN4QztnREFBRztRQUFDO1FBQU8sYUFBYTtLQUFDO0lBRXpCLE1BQU0sWUFBWSxnRUFBWSxDQUFDO1FBQUM7UUFBUSxZQUFZO0tBQUM7SUFDckQsT0FBTyx1RUFBQztRQUFJLEtBQUs7UUFBWSxHQUFHO0lBQUEsQ0FBVTtBQUM1QztBQUdGLFlBQVksY0FBYyIsInNvdXJjZXMiOlsiL1VzZXJzL2ltcmFubW9oYW1tZWQvZGVzaWduLXdpdGgtY2xhdWRlL3NyYy9zaGFkZXItbW91bnQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIGZvcndhcmRSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHtcbiAgU2hhZGVyTW91bnQgYXMgU2hhZGVyTW91bnRWYW5pbGxhLFxuICB0eXBlIFBhcGVyU2hhZGVyRWxlbWVudCxcbiAgdHlwZSBTaGFkZXJNb3Rpb25QYXJhbXMsXG4gIHR5cGUgU2hhZGVyTW91bnRVbmlmb3Jtcyxcbn0gZnJvbSAnQHBhcGVyLWRlc2lnbi9zaGFkZXJzJztcbmltcG9ydCB7IHVzZU1lcmdlUmVmcyB9IGZyb20gJy4vdXNlLW1lcmdlLXJlZnMuanMnO1xuXG4vKipcbiAqIFJlYWN0IFNoYWRlciBNb3VudCBjYW4gYWxzbyBhY2NlcHQgc3RyaW5ncyBhcyB1bmlmb3JtIHZhbHVlcywgd2hpY2ggd2lsbCBhc3N1bWVkIHRvIGJlIFVSTHMgYW5kIGxvYWRlZCBhcyBpbWFnZXNcbiAqXG4gKiBXZSBhY2NlcHQgdW5kZWZpbmVkIGFzIGEgY29udmVuaWVuY2UgZm9yIHNlcnZlciByZW5kZXJpbmcsIHdoZW4gc29tZSB0aGluZ3MgbWF5IGJlIHVuZGVmaW5lZFxuICogV2UganVzdCBza2lwIHNldHRpbmcgdGhlIHVuaWZvcm0gaWYgaXQncyB1bmRlZmluZWQuIFRoaXMgYWxsb3dzIHRoZSBzaGFkZXIgbW91bnQgdG8gc3RpbGwgdGFrZSB1cCBzcGFjZSBkdXJpbmcgc2VydmVyIHJlbmRlcmluZ1xuICovXG5pbnRlcmZhY2UgU2hhZGVyTW91bnRVbmlmb3Jtc1JlYWN0IHtcbiAgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgYm9vbGVhbiB8IG51bWJlciB8IG51bWJlcltdIHwgbnVtYmVyW11bXSB8IEhUTUxJbWFnZUVsZW1lbnQgfCB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2hhZGVyTW91bnRQcm9wcyBleHRlbmRzIE9taXQ8UmVhY3QuQ29tcG9uZW50UHJvcHM8J2Rpdic+LCAnY29sb3InIHwgJ3JlZic+LCBTaGFkZXJNb3Rpb25QYXJhbXMge1xuICByZWY/OiBSZWFjdC5SZWY8UGFwZXJTaGFkZXJFbGVtZW50PjtcbiAgZnJhZ21lbnRTaGFkZXI6IHN0cmluZztcbiAgdW5pZm9ybXM6IFNoYWRlck1vdW50VW5pZm9ybXNSZWFjdDtcbiAgbWluUGl4ZWxSYXRpbz86IG51bWJlcjtcbiAgbWF4UGl4ZWxDb3VudD86IG51bWJlcjtcbiAgd2ViR2xDb250ZXh0QXR0cmlidXRlcz86IFdlYkdMQ29udGV4dEF0dHJpYnV0ZXM7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2hhZGVyQ29tcG9uZW50UHJvcHMgZXh0ZW5kcyBPbWl0PFJlYWN0LkNvbXBvbmVudFByb3BzPCdkaXYnPiwgJ2NvbG9yJyB8ICdyZWYnPiB7XG4gIHJlZj86IFJlYWN0LlJlZjxQYXBlclNoYWRlckVsZW1lbnQ+O1xuICBtaW5QaXhlbFJhdGlvPzogbnVtYmVyO1xuICBtYXhQaXhlbENvdW50PzogbnVtYmVyO1xuICB3ZWJHbENvbnRleHRBdHRyaWJ1dGVzPzogV2ViR0xDb250ZXh0QXR0cmlidXRlcztcbn1cblxuLyoqIFBhcnNlIHRoZSBwcm92aWRlZCB1bmlmb3JtcywgdHVybmluZyBVUkwgc3RyaW5ncyBpbnRvIGxvYWRlZCBpbWFnZXMgKi9cbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NVbmlmb3Jtcyh1bmlmb3Jtc1Byb3A6IFNoYWRlck1vdW50VW5pZm9ybXNSZWFjdCk6IFByb21pc2U8U2hhZGVyTW91bnRVbmlmb3Jtcz4ge1xuICBjb25zdCBwcm9jZXNzZWRVbmlmb3JtcyA9IHt9IGFzIFNoYWRlck1vdW50VW5pZm9ybXM7XG4gIGNvbnN0IGltYWdlTG9hZFByb21pc2VzOiBQcm9taXNlPHZvaWQ+W10gPSBbXTtcblxuICBjb25zdCBpc1ZhbGlkVXJsID0gKHVybDogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEhhbmRsZSBhYnNvbHV0ZSBwYXRoc1xuICAgICAgaWYgKHVybC5zdGFydHNXaXRoKCcvJykpIHJldHVybiB0cnVlO1xuICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhIHZhbGlkIFVSTFxuICAgICAgbmV3IFVSTCh1cmwpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGlzRXh0ZXJuYWxVcmwgPSAodXJsOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKHVybC5zdGFydHNXaXRoKCcvJykpIHJldHVybiBmYWxzZTtcbiAgICAgIGNvbnN0IHVybE9iamVjdCA9IG5ldyBVUkwodXJsLCB3aW5kb3cubG9jYXRpb24ub3JpZ2luKTtcbiAgICAgIHJldHVybiB1cmxPYmplY3Qub3JpZ2luICE9PSB3aW5kb3cubG9jYXRpb24ub3JpZ2luO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBPYmplY3QuZW50cmllcyh1bmlmb3Jtc1Byb3ApLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBNYWtlIHN1cmUgdGhlIHByb3ZpZGVkIHN0cmluZyBpcyBhIHZhbGlkIFVSTCBvciBqdXN0IHNraXAgdHJ5aW5nIHRvIHNldCB0aGlzIHVuaWZvcm0gZW50aXJlbHlcbiAgICAgIGlmICghaXNWYWxpZFVybCh2YWx1ZSkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBVbmlmb3JtIFwiJHtrZXl9XCIgaGFzIGludmFsaWQgVVJMIFwiJHt2YWx1ZX1cIi4gU2tpcHBpbmcgaW1hZ2UgbG9hZGluZy5gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpbWFnZVByb21pc2UgPSBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBpZiAoaXNFeHRlcm5hbFVybCh2YWx1ZSkpIHtcbiAgICAgICAgICBpbWcuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcbiAgICAgICAgfVxuICAgICAgICBpbWcub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgIHByb2Nlc3NlZFVuaWZvcm1zW2tleV0gPSBpbWc7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICBpbWcub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBDb3VsZCBub3Qgc2V0IHVuaWZvcm1zLiBGYWlsZWQgdG8gbG9hZCBpbWFnZSBhdCAke3ZhbHVlfWApO1xuICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICB9O1xuICAgICAgICBpbWcuc3JjID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICAgIGltYWdlTG9hZFByb21pc2VzLnB1c2goaW1hZ2VQcm9taXNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzc2VkVW5pZm9ybXNba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG5cbiAgYXdhaXQgUHJvbWlzZS5hbGwoaW1hZ2VMb2FkUHJvbWlzZXMpO1xuICByZXR1cm4gcHJvY2Vzc2VkVW5pZm9ybXM7XG59XG5cbi8qKlxuICogQSBSZWFjdCBjb21wb25lbnQgdGhhdCBtb3VudHMgYSBzaGFkZXIgYW5kIHVwZGF0ZXMgaXRzIHVuaWZvcm1zIGFzIHRoZSBjb21wb25lbnQncyBwcm9wcyBjaGFuZ2VcbiAqIElmIHlvdSBwYXNzIGEgc3RyaW5nIGFzIGEgdW5pZm9ybSB2YWx1ZSwgaXQgd2lsbCBiZSBhc3N1bWVkIHRvIGJlIGEgVVJMIGFuZCBhdHRlbXB0ZWQgdG8gYmUgbG9hZGVkIGFzIGFuIGltYWdlXG4gKi9cbmV4cG9ydCBjb25zdCBTaGFkZXJNb3VudDogUmVhY3QuRkM8U2hhZGVyTW91bnRQcm9wcz4gPSBmb3J3YXJkUmVmPFBhcGVyU2hhZGVyRWxlbWVudCwgU2hhZGVyTW91bnRQcm9wcz4oXG4gIGZ1bmN0aW9uIFNoYWRlck1vdW50SW1wbChcbiAgICB7XG4gICAgICBmcmFnbWVudFNoYWRlcixcbiAgICAgIHVuaWZvcm1zOiB1bmlmb3Jtc1Byb3AsXG4gICAgICB3ZWJHbENvbnRleHRBdHRyaWJ1dGVzLFxuICAgICAgc3BlZWQgPSAwLFxuICAgICAgZnJhbWUgPSAwLFxuICAgICAgbWluUGl4ZWxSYXRpbyxcbiAgICAgIG1heFBpeGVsQ291bnQsXG4gICAgICAuLi5kaXZQcm9wc1xuICAgIH0sXG4gICAgZm9yd2FyZGVkUmVmXG4gICkge1xuICAgIGNvbnN0IFtpc0luaXRpYWxpemVkLCBzZXRJc0luaXRpYWxpemVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBkaXZSZWYgPSB1c2VSZWY8UGFwZXJTaGFkZXJFbGVtZW50PihudWxsKTtcbiAgICBjb25zdCBzaGFkZXJNb3VudFJlZjogUmVhY3QuUmVmT2JqZWN0PFNoYWRlck1vdW50VmFuaWxsYSB8IG51bGw+ID0gdXNlUmVmPFNoYWRlck1vdW50VmFuaWxsYT4obnVsbCk7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBTaGFkZXJNb3VudFZhbmlsbGFcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgY29uc3QgaW5pdFNoYWRlciA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgdW5pZm9ybXMgPSBhd2FpdCBwcm9jZXNzVW5pZm9ybXModW5pZm9ybXNQcm9wKTtcblxuICAgICAgICBpZiAoZGl2UmVmLmN1cnJlbnQgJiYgIXNoYWRlck1vdW50UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICBzaGFkZXJNb3VudFJlZi5jdXJyZW50ID0gbmV3IFNoYWRlck1vdW50VmFuaWxsYShcbiAgICAgICAgICAgIGRpdlJlZi5jdXJyZW50LFxuICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXIsXG4gICAgICAgICAgICB1bmlmb3JtcyxcbiAgICAgICAgICAgIHdlYkdsQ29udGV4dEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBzcGVlZCxcbiAgICAgICAgICAgIGZyYW1lLFxuICAgICAgICAgICAgbWluUGl4ZWxSYXRpbyxcbiAgICAgICAgICAgIG1heFBpeGVsQ291bnRcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgc2V0SXNJbml0aWFsaXplZCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaW5pdFNoYWRlcigpO1xuXG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBzaGFkZXJNb3VudFJlZi5jdXJyZW50Py5kaXNwb3NlKCk7XG4gICAgICAgIHNoYWRlck1vdW50UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfTtcbiAgICB9LCBbZnJhZ21lbnRTaGFkZXIsIHdlYkdsQ29udGV4dEF0dHJpYnV0ZXNdKTtcblxuICAgIC8vIFVuaWZvcm1zXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGxldCBpc1N0YWxlID0gZmFsc2U7XG5cbiAgICAgIGNvbnN0IHVwZGF0ZVVuaWZvcm1zID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCB1bmlmb3JtcyA9IGF3YWl0IHByb2Nlc3NVbmlmb3Jtcyh1bmlmb3Jtc1Byb3ApO1xuXG4gICAgICAgIGlmICghaXNTdGFsZSkge1xuICAgICAgICAgIC8vIFdlIG9ubHkgdXNlIHRoZSBmcmVzaGVzdCB1bmlmb3JtcyBvdGhlcndpc2Ugd2UgY2FuIGdldCBpbnRvIHJhY2UgY29uZGl0aW9uc1xuICAgICAgICAgIC8vIGlmIHNvbWUgdW5pZm9ybXMgKGltYWdlcyEpIHRha2UgbG9uZ2VyIHRvIGxvYWQgaW4gc3Vic2VxdWVudCBlZmZlY3QgcnVucy5cbiAgICAgICAgICBzaGFkZXJNb3VudFJlZi5jdXJyZW50Py5zZXRVbmlmb3Jtcyh1bmlmb3Jtcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHVwZGF0ZVVuaWZvcm1zKCk7XG5cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlzU3RhbGUgPSB0cnVlO1xuICAgICAgfTtcbiAgICB9LCBbdW5pZm9ybXNQcm9wLCBpc0luaXRpYWxpemVkXSk7XG5cbiAgICAvLyBTcGVlZFxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBzaGFkZXJNb3VudFJlZi5jdXJyZW50Py5zZXRTcGVlZChzcGVlZCk7XG4gICAgfSwgW3NwZWVkLCBpc0luaXRpYWxpemVkXSk7XG5cbiAgICAvLyBNYXggUGl4ZWwgQ291bnRcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgc2hhZGVyTW91bnRSZWYuY3VycmVudD8uc2V0TWF4UGl4ZWxDb3VudChtYXhQaXhlbENvdW50KTtcbiAgICB9LCBbbWF4UGl4ZWxDb3VudCwgaXNJbml0aWFsaXplZF0pO1xuXG4gICAgLy8gTWluIFBpeGVsIFJhdGlvXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIHNoYWRlck1vdW50UmVmLmN1cnJlbnQ/LnNldE1pblBpeGVsUmF0aW8obWluUGl4ZWxSYXRpbyk7XG4gICAgfSwgW21pblBpeGVsUmF0aW8sIGlzSW5pdGlhbGl6ZWRdKTtcblxuICAgIC8vIEZyYW1lXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIHNoYWRlck1vdW50UmVmLmN1cnJlbnQ/LnNldEZyYW1lKGZyYW1lKTtcbiAgICB9LCBbZnJhbWUsIGlzSW5pdGlhbGl6ZWRdKTtcblxuICAgIGNvbnN0IG1lcmdlZFJlZiA9IHVzZU1lcmdlUmVmcyhbZGl2UmVmLCBmb3J3YXJkZWRSZWZdKSBhcyB1bmtub3duIGFzIFJlYWN0LlJlZk9iamVjdDxIVE1MRGl2RWxlbWVudD47XG4gICAgcmV0dXJuIDxkaXYgcmVmPXttZXJnZWRSZWZ9IHsuLi5kaXZQcm9wc30gLz47XG4gIH1cbik7XG5cblNoYWRlck1vdW50LmRpc3BsYXlOYW1lID0gJ1NoYWRlck1vdW50JztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders-react/dist/shader-mount.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders-react/dist/shaders/mesh-gradient.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@paper-design/shaders-react/dist/shaders/mesh-gradient.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MeshGradient: () => (/* binding */ MeshGradient),\n/* harmony export */   beachPreset: () => (/* binding */ beachPreset),\n/* harmony export */   defaultPreset: () => (/* binding */ defaultPreset),\n/* harmony export */   inkPreset: () => (/* binding */ inkPreset),\n/* harmony export */   meshGradientPresets: () => (/* binding */ meshGradientPresets),\n/* harmony export */   purplePreset: () => (/* binding */ purplePreset)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _shader_mount_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shader-mount.js */ \"(ssr)/./node_modules/@paper-design/shaders-react/dist/shader-mount.js\");\n/* harmony import */ var _color_props_are_equal_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../color-props-are-equal.js */ \"(ssr)/./node_modules/@paper-design/shaders-react/dist/color-props-are-equal.js\");\n/* harmony import */ var _paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @paper-design/shaders */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shader-sizing.js\");\n/* harmony import */ var _paper_design_shaders__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @paper-design/shaders */ \"(ssr)/./node_modules/@paper-design/shaders/dist/get-shader-color-from-string.js\");\n/* harmony import */ var _paper_design_shaders__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @paper-design/shaders */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shaders/mesh-gradient.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\n\n\n\n\nconst defaultPreset = {\n  name: \"Default\",\n  params: {\n    ..._paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    colors: [\"#e0eaff\", \"#241d9a\", \"#f75092\", \"#9f50d3\"],\n    distortion: 0.8,\n    swirl: 0.1\n  }\n};\nconst purplePreset = {\n  name: \"Purple\",\n  params: {\n    ..._paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.defaultObjectSizing,\n    speed: 0.6,\n    frame: 0,\n    colors: [\"#aaa7d7\", \"#3c2b8e\"],\n    distortion: 1,\n    swirl: 1\n  }\n};\nconst beachPreset = {\n  name: \"Beach\",\n  params: {\n    ..._paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.defaultObjectSizing,\n    speed: 0.1,\n    frame: 0,\n    colors: [\"#bcecf6\", \"#00aaff\", \"#00f7ff\", \"#ffd447\"],\n    distortion: 0.8,\n    swirl: 0.35\n  }\n};\nconst inkPreset = {\n  name: \"Ink\",\n  params: {\n    ..._paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.defaultObjectSizing,\n    speed: 1,\n    frame: 0,\n    colors: [\"#ffffff\", \"#000000\"],\n    distortion: 1,\n    swirl: 0.2,\n    rotation: 90\n  }\n};\nconst meshGradientPresets = [defaultPreset, inkPreset, purplePreset, beachPreset];\nconst MeshGradient = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(function MeshGradientImpl({\n  // Own props\n  speed = defaultPreset.params.speed,\n  frame = defaultPreset.params.frame,\n  colors = defaultPreset.params.colors,\n  distortion = defaultPreset.params.distortion,\n  swirl = defaultPreset.params.swirl,\n  // Sizing props\n  fit = defaultPreset.params.fit,\n  rotation = defaultPreset.params.rotation,\n  scale = defaultPreset.params.scale,\n  originX = defaultPreset.params.originX,\n  originY = defaultPreset.params.originY,\n  offsetX = defaultPreset.params.offsetX,\n  offsetY = defaultPreset.params.offsetY,\n  worldWidth = defaultPreset.params.worldWidth,\n  worldHeight = defaultPreset.params.worldHeight,\n  ...props\n}) {\n  const uniforms = {\n    // Own uniforms\n    u_colors: colors.map(_paper_design_shaders__WEBPACK_IMPORTED_MODULE_3__.getShaderColorFromString),\n    u_colorsCount: colors.length,\n    u_distortion: distortion,\n    u_swirl: swirl,\n    // Sizing uniforms\n    u_fit: _paper_design_shaders__WEBPACK_IMPORTED_MODULE_2__.ShaderFitOptions[fit],\n    u_rotation: rotation,\n    u_scale: scale,\n    u_offsetX: offsetX,\n    u_offsetY: offsetY,\n    u_originX: originX,\n    u_originY: originY,\n    u_worldWidth: worldWidth,\n    u_worldHeight: worldHeight\n  };\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\n    _shader_mount_js__WEBPACK_IMPORTED_MODULE_4__.ShaderMount,\n    {\n      ...props,\n      speed,\n      frame,\n      fragmentShader: _paper_design_shaders__WEBPACK_IMPORTED_MODULE_5__.meshGradientFragmentShader,\n      uniforms\n    }\n  );\n}, _color_props_are_equal_js__WEBPACK_IMPORTED_MODULE_6__.colorPropsAreEqual);\n\n//# sourceMappingURL=mesh-gradient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3Qvc2hhZGVycy9tZXNoLWdyYWRpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNkI7QUFDb0I7QUFDZ0I7QUFNbEM7QUFDUztBQUN4QztBQUNBO0FBQ0E7QUFDQSxPQUFPLHNFQUFtQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sc0VBQW1CO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxzRUFBbUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHNFQUFtQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkNBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EseUJBQXlCLDJFQUF3QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUVBQWdCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixzREFBRztBQUM1QixJQUFJLHlEQUFXO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNkVBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRSx5RUFBa0I7QUFRbkI7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2ltcmFubW9oYW1tZWQvZGVzaWduLXdpdGgtY2xhdWRlL3dlYi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3Qvc2hhZGVycy9tZXNoLWdyYWRpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiAgICAgICAgICAgICAgICAgICAgUGFwZXIgU2hhZGVycyAgICAgICAgICAgICAgICAgICAgKlxuICogICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3BhcGVyLWRlc2lnbi9zaGFkZXJzICAgICAgICpcbiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuXG5pbXBvcnQgeyBtZW1vIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBTaGFkZXJNb3VudCB9IGZyb20gXCIuLi9zaGFkZXItbW91bnQuanNcIjtcbmltcG9ydCB7IGNvbG9yUHJvcHNBcmVFcXVhbCB9IGZyb20gXCIuLi9jb2xvci1wcm9wcy1hcmUtZXF1YWwuanNcIjtcbmltcG9ydCB7XG4gIGRlZmF1bHRPYmplY3RTaXppbmcsXG4gIGdldFNoYWRlckNvbG9yRnJvbVN0cmluZyxcbiAgbWVzaEdyYWRpZW50RnJhZ21lbnRTaGFkZXIsXG4gIFNoYWRlckZpdE9wdGlvbnNcbn0gZnJvbSBcIkBwYXBlci1kZXNpZ24vc2hhZGVyc1wiO1xuaW1wb3J0IHsganN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5jb25zdCBkZWZhdWx0UHJlc2V0ID0ge1xuICBuYW1lOiBcIkRlZmF1bHRcIixcbiAgcGFyYW1zOiB7XG4gICAgLi4uZGVmYXVsdE9iamVjdFNpemluZyxcbiAgICBzcGVlZDogMSxcbiAgICBmcmFtZTogMCxcbiAgICBjb2xvcnM6IFtcIiNlMGVhZmZcIiwgXCIjMjQxZDlhXCIsIFwiI2Y3NTA5MlwiLCBcIiM5ZjUwZDNcIl0sXG4gICAgZGlzdG9ydGlvbjogMC44LFxuICAgIHN3aXJsOiAwLjFcbiAgfVxufTtcbmNvbnN0IHB1cnBsZVByZXNldCA9IHtcbiAgbmFtZTogXCJQdXJwbGVcIixcbiAgcGFyYW1zOiB7XG4gICAgLi4uZGVmYXVsdE9iamVjdFNpemluZyxcbiAgICBzcGVlZDogMC42LFxuICAgIGZyYW1lOiAwLFxuICAgIGNvbG9yczogW1wiI2FhYTdkN1wiLCBcIiMzYzJiOGVcIl0sXG4gICAgZGlzdG9ydGlvbjogMSxcbiAgICBzd2lybDogMVxuICB9XG59O1xuY29uc3QgYmVhY2hQcmVzZXQgPSB7XG4gIG5hbWU6IFwiQmVhY2hcIixcbiAgcGFyYW1zOiB7XG4gICAgLi4uZGVmYXVsdE9iamVjdFNpemluZyxcbiAgICBzcGVlZDogMC4xLFxuICAgIGZyYW1lOiAwLFxuICAgIGNvbG9yczogW1wiI2JjZWNmNlwiLCBcIiMwMGFhZmZcIiwgXCIjMDBmN2ZmXCIsIFwiI2ZmZDQ0N1wiXSxcbiAgICBkaXN0b3J0aW9uOiAwLjgsXG4gICAgc3dpcmw6IDAuMzVcbiAgfVxufTtcbmNvbnN0IGlua1ByZXNldCA9IHtcbiAgbmFtZTogXCJJbmtcIixcbiAgcGFyYW1zOiB7XG4gICAgLi4uZGVmYXVsdE9iamVjdFNpemluZyxcbiAgICBzcGVlZDogMSxcbiAgICBmcmFtZTogMCxcbiAgICBjb2xvcnM6IFtcIiNmZmZmZmZcIiwgXCIjMDAwMDAwXCJdLFxuICAgIGRpc3RvcnRpb246IDEsXG4gICAgc3dpcmw6IDAuMixcbiAgICByb3RhdGlvbjogOTBcbiAgfVxufTtcbmNvbnN0IG1lc2hHcmFkaWVudFByZXNldHMgPSBbZGVmYXVsdFByZXNldCwgaW5rUHJlc2V0LCBwdXJwbGVQcmVzZXQsIGJlYWNoUHJlc2V0XTtcbmNvbnN0IE1lc2hHcmFkaWVudCA9IG1lbW8oZnVuY3Rpb24gTWVzaEdyYWRpZW50SW1wbCh7XG4gIC8vIE93biBwcm9wc1xuICBzcGVlZCA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLnNwZWVkLFxuICBmcmFtZSA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLmZyYW1lLFxuICBjb2xvcnMgPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5jb2xvcnMsXG4gIGRpc3RvcnRpb24gPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5kaXN0b3J0aW9uLFxuICBzd2lybCA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLnN3aXJsLFxuICAvLyBTaXppbmcgcHJvcHNcbiAgZml0ID0gZGVmYXVsdFByZXNldC5wYXJhbXMuZml0LFxuICByb3RhdGlvbiA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLnJvdGF0aW9uLFxuICBzY2FsZSA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLnNjYWxlLFxuICBvcmlnaW5YID0gZGVmYXVsdFByZXNldC5wYXJhbXMub3JpZ2luWCxcbiAgb3JpZ2luWSA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLm9yaWdpblksXG4gIG9mZnNldFggPSBkZWZhdWx0UHJlc2V0LnBhcmFtcy5vZmZzZXRYLFxuICBvZmZzZXRZID0gZGVmYXVsdFByZXNldC5wYXJhbXMub2Zmc2V0WSxcbiAgd29ybGRXaWR0aCA9IGRlZmF1bHRQcmVzZXQucGFyYW1zLndvcmxkV2lkdGgsXG4gIHdvcmxkSGVpZ2h0ID0gZGVmYXVsdFByZXNldC5wYXJhbXMud29ybGRIZWlnaHQsXG4gIC4uLnByb3BzXG59KSB7XG4gIGNvbnN0IHVuaWZvcm1zID0ge1xuICAgIC8vIE93biB1bmlmb3Jtc1xuICAgIHVfY29sb3JzOiBjb2xvcnMubWFwKGdldFNoYWRlckNvbG9yRnJvbVN0cmluZyksXG4gICAgdV9jb2xvcnNDb3VudDogY29sb3JzLmxlbmd0aCxcbiAgICB1X2Rpc3RvcnRpb246IGRpc3RvcnRpb24sXG4gICAgdV9zd2lybDogc3dpcmwsXG4gICAgLy8gU2l6aW5nIHVuaWZvcm1zXG4gICAgdV9maXQ6IFNoYWRlckZpdE9wdGlvbnNbZml0XSxcbiAgICB1X3JvdGF0aW9uOiByb3RhdGlvbixcbiAgICB1X3NjYWxlOiBzY2FsZSxcbiAgICB1X29mZnNldFg6IG9mZnNldFgsXG4gICAgdV9vZmZzZXRZOiBvZmZzZXRZLFxuICAgIHVfb3JpZ2luWDogb3JpZ2luWCxcbiAgICB1X29yaWdpblk6IG9yaWdpblksXG4gICAgdV93b3JsZFdpZHRoOiB3b3JsZFdpZHRoLFxuICAgIHVfd29ybGRIZWlnaHQ6IHdvcmxkSGVpZ2h0XG4gIH07XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgIFNoYWRlck1vdW50LFxuICAgIHtcbiAgICAgIC4uLnByb3BzLFxuICAgICAgc3BlZWQsXG4gICAgICBmcmFtZSxcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBtZXNoR3JhZGllbnRGcmFnbWVudFNoYWRlcixcbiAgICAgIHVuaWZvcm1zXG4gICAgfVxuICApO1xufSwgY29sb3JQcm9wc0FyZUVxdWFsKTtcbmV4cG9ydCB7XG4gIE1lc2hHcmFkaWVudCxcbiAgYmVhY2hQcmVzZXQsXG4gIGRlZmF1bHRQcmVzZXQsXG4gIGlua1ByZXNldCxcbiAgbWVzaEdyYWRpZW50UHJlc2V0cyxcbiAgcHVycGxlUHJlc2V0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVzaC1ncmFkaWVudC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders-react/dist/shaders/mesh-gradient.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders-react/dist/use-merge-refs.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@paper-design/shaders-react/dist/use-merge-refs.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useMergeRefs: () => (/* binding */ useMergeRefs)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\nfunction useMergeRefs(refs) {\n  const cleanupRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);\n  const refEffect = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((instance) => {\n    const cleanups = refs.map((ref) => {\n      if (ref == null) {\n        return;\n      }\n      if (typeof ref === \"function\") {\n        const refCallback = ref;\n        const refCleanup = refCallback(instance);\n        return typeof refCleanup === \"function\" ? refCleanup : () => {\n          refCallback(null);\n        };\n      }\n      ref.current = instance;\n      return () => {\n        ref.current = null;\n      };\n    });\n    return () => {\n      cleanups.forEach((refCleanup) => refCleanup?.());\n    };\n  }, refs);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (refs.every((ref) => ref == null)) {\n      return null;\n    }\n    return (value) => {\n      if (cleanupRef.current) {\n        cleanupRef.current();\n        cleanupRef.current = void 0;\n      }\n      if (value != null) {\n        cleanupRef.current = refEffect(value);\n      }\n    };\n  }, refs);\n}\n\n//# sourceMappingURL=use-merge-refs.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3QvdXNlLW1lcmdlLXJlZnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0I7QUFDL0I7QUFDQSxxQkFBcUIseUNBQVk7QUFDakMsb0JBQW9CLDhDQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFNBQVMsMENBQWE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2ltcmFubW9oYW1tZWQvZGVzaWduLXdpdGgtY2xhdWRlL3dlYi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzLXJlYWN0L2Rpc3QvdXNlLW1lcmdlLXJlZnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqICAgICAgICAgICAgICAgICAgICBQYXBlciBTaGFkZXJzICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICBodHRwczovL2dpdGh1Yi5jb20vcGFwZXItZGVzaWduL3NoYWRlcnMgICAgICAgKlxuICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICovXG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gdXNlTWVyZ2VSZWZzKHJlZnMpIHtcbiAgY29uc3QgY2xlYW51cFJlZiA9IFJlYWN0LnVzZVJlZih2b2lkIDApO1xuICBjb25zdCByZWZFZmZlY3QgPSBSZWFjdC51c2VDYWxsYmFjaygoaW5zdGFuY2UpID0+IHtcbiAgICBjb25zdCBjbGVhbnVwcyA9IHJlZnMubWFwKChyZWYpID0+IHtcbiAgICAgIGlmIChyZWYgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHJlZiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHJlZkNhbGxiYWNrID0gcmVmO1xuICAgICAgICBjb25zdCByZWZDbGVhbnVwID0gcmVmQ2FsbGJhY2soaW5zdGFuY2UpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHJlZkNsZWFudXAgPT09IFwiZnVuY3Rpb25cIiA/IHJlZkNsZWFudXAgOiAoKSA9PiB7XG4gICAgICAgICAgcmVmQ2FsbGJhY2sobnVsbCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZWYuY3VycmVudCA9IGluc3RhbmNlO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYW51cHMuZm9yRWFjaCgocmVmQ2xlYW51cCkgPT4gcmVmQ2xlYW51cD8uKCkpO1xuICAgIH07XG4gIH0sIHJlZnMpO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKHJlZnMuZXZlcnkoKHJlZikgPT4gcmVmID09IG51bGwpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKGNsZWFudXBSZWYuY3VycmVudCkge1xuICAgICAgICBjbGVhbnVwUmVmLmN1cnJlbnQoKTtcbiAgICAgICAgY2xlYW51cFJlZi5jdXJyZW50ID0gdm9pZCAwO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgY2xlYW51cFJlZi5jdXJyZW50ID0gcmVmRWZmZWN0KHZhbHVlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCByZWZzKTtcbn1cbmV4cG9ydCB7XG4gIHVzZU1lcmdlUmVmc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1tZXJnZS1yZWZzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders-react/dist/use-merge-refs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/get-shader-color-from-string.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/get-shader-color-from-string.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   getShaderColorFromString: () => (/* binding */ getShaderColorFromString)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nfunction getShaderColorFromString(colorString) {\n  if (Array.isArray(colorString)) {\n    if (colorString.length === 4) return colorString;\n    if (colorString.length === 3) return [...colorString, 1];\n    return fallbackColor;\n  }\n  if (typeof colorString !== \"string\") {\n    return fallbackColor;\n  }\n  let r, g, b, a = 1;\n  if (colorString.startsWith(\"#\")) {\n    [r, g, b, a] = hexToRgba(colorString);\n  } else if (colorString.startsWith(\"rgb\")) {\n    [r, g, b, a] = parseRgba(colorString);\n  } else if (colorString.startsWith(\"hsl\")) {\n    [r, g, b, a] = hslaToRgba(parseHsla(colorString));\n  } else {\n    console.error(\"Unsupported color format\", colorString);\n    return fallbackColor;\n  }\n  return [clamp(r, 0, 1), clamp(g, 0, 1), clamp(b, 0, 1), clamp(a, 0, 1)];\n}\nfunction hexToRgba(hex) {\n  hex = hex.replace(/^#/, \"\");\n  if (hex.length === 3) {\n    hex = hex.split(\"\").map((char) => char + char).join(\"\");\n  }\n  if (hex.length === 6) {\n    hex = hex + \"ff\";\n  }\n  const r = parseInt(hex.slice(0, 2), 16) / 255;\n  const g = parseInt(hex.slice(2, 4), 16) / 255;\n  const b = parseInt(hex.slice(4, 6), 16) / 255;\n  const a = parseInt(hex.slice(6, 8), 16) / 255;\n  return [r, g, b, a];\n}\nfunction parseRgba(rgba) {\n  const match = rgba.match(/^rgba?\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*([0-9.]+))?\\s*\\)$/i);\n  if (!match) return [0, 0, 0, 1];\n  return [\n    parseInt(match[1] ?? \"0\") / 255,\n    parseInt(match[2] ?? \"0\") / 255,\n    parseInt(match[3] ?? \"0\") / 255,\n    match[4] === void 0 ? 1 : parseFloat(match[4])\n  ];\n}\nfunction parseHsla(hsla) {\n  const match = hsla.match(/^hsla?\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*(?:,\\s*([0-9.]+))?\\s*\\)$/i);\n  if (!match) return [0, 0, 0, 1];\n  return [\n    parseInt(match[1] ?? \"0\"),\n    parseInt(match[2] ?? \"0\"),\n    parseInt(match[3] ?? \"0\"),\n    match[4] === void 0 ? 1 : parseFloat(match[4])\n  ];\n}\nfunction hslaToRgba(hsla) {\n  const [h, s, l, a] = hsla;\n  const hDecimal = h / 360;\n  const sDecimal = s / 100;\n  const lDecimal = l / 100;\n  let r, g, b;\n  if (s === 0) {\n    r = g = b = lDecimal;\n  } else {\n    const hue2rgb = (p2, q2, t) => {\n      if (t < 0) t += 1;\n      if (t > 1) t -= 1;\n      if (t < 1 / 6) return p2 + (q2 - p2) * 6 * t;\n      if (t < 1 / 2) return q2;\n      if (t < 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;\n      return p2;\n    };\n    const q = lDecimal < 0.5 ? lDecimal * (1 + sDecimal) : lDecimal + sDecimal - lDecimal * sDecimal;\n    const p = 2 * lDecimal - q;\n    r = hue2rgb(p, q, hDecimal + 1 / 3);\n    g = hue2rgb(p, q, hDecimal);\n    b = hue2rgb(p, q, hDecimal - 1 / 3);\n  }\n  return [r, g, b, a];\n}\nconst clamp = (n, min, max) => Math.min(Math.max(n, min), max);\nconst fallbackColor = [0, 0, 0, 1];\n\n//# sourceMappingURL=get-shader-color-from-string.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3QvZ2V0LXNoYWRlci1jb2xvci1mcm9tLXN0cmluZy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9pbXJhbm1vaGFtbWVkL2Rlc2lnbi13aXRoLWNsYXVkZS93ZWIvbm9kZV9tb2R1bGVzL0BwYXBlci1kZXNpZ24vc2hhZGVycy9kaXN0L2dldC1zaGFkZXItY29sb3ItZnJvbS1zdHJpbmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqICAgICAgICAgICAgICAgICAgICBQYXBlciBTaGFkZXJzICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICBodHRwczovL2dpdGh1Yi5jb20vcGFwZXItZGVzaWduL3NoYWRlcnMgICAgICAgKlxuICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICovXG5cbmZ1bmN0aW9uIGdldFNoYWRlckNvbG9yRnJvbVN0cmluZyhjb2xvclN0cmluZykge1xuICBpZiAoQXJyYXkuaXNBcnJheShjb2xvclN0cmluZykpIHtcbiAgICBpZiAoY29sb3JTdHJpbmcubGVuZ3RoID09PSA0KSByZXR1cm4gY29sb3JTdHJpbmc7XG4gICAgaWYgKGNvbG9yU3RyaW5nLmxlbmd0aCA9PT0gMykgcmV0dXJuIFsuLi5jb2xvclN0cmluZywgMV07XG4gICAgcmV0dXJuIGZhbGxiYWNrQ29sb3I7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb2xvclN0cmluZyAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBmYWxsYmFja0NvbG9yO1xuICB9XG4gIGxldCByLCBnLCBiLCBhID0gMTtcbiAgaWYgKGNvbG9yU3RyaW5nLnN0YXJ0c1dpdGgoXCIjXCIpKSB7XG4gICAgW3IsIGcsIGIsIGFdID0gaGV4VG9SZ2JhKGNvbG9yU3RyaW5nKTtcbiAgfSBlbHNlIGlmIChjb2xvclN0cmluZy5zdGFydHNXaXRoKFwicmdiXCIpKSB7XG4gICAgW3IsIGcsIGIsIGFdID0gcGFyc2VSZ2JhKGNvbG9yU3RyaW5nKTtcbiAgfSBlbHNlIGlmIChjb2xvclN0cmluZy5zdGFydHNXaXRoKFwiaHNsXCIpKSB7XG4gICAgW3IsIGcsIGIsIGFdID0gaHNsYVRvUmdiYShwYXJzZUhzbGEoY29sb3JTdHJpbmcpKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKFwiVW5zdXBwb3J0ZWQgY29sb3IgZm9ybWF0XCIsIGNvbG9yU3RyaW5nKTtcbiAgICByZXR1cm4gZmFsbGJhY2tDb2xvcjtcbiAgfVxuICByZXR1cm4gW2NsYW1wKHIsIDAsIDEpLCBjbGFtcChnLCAwLCAxKSwgY2xhbXAoYiwgMCwgMSksIGNsYW1wKGEsIDAsIDEpXTtcbn1cbmZ1bmN0aW9uIGhleFRvUmdiYShoZXgpIHtcbiAgaGV4ID0gaGV4LnJlcGxhY2UoL14jLywgXCJcIik7XG4gIGlmIChoZXgubGVuZ3RoID09PSAzKSB7XG4gICAgaGV4ID0gaGV4LnNwbGl0KFwiXCIpLm1hcCgoY2hhcikgPT4gY2hhciArIGNoYXIpLmpvaW4oXCJcIik7XG4gIH1cbiAgaWYgKGhleC5sZW5ndGggPT09IDYpIHtcbiAgICBoZXggPSBoZXggKyBcImZmXCI7XG4gIH1cbiAgY29uc3QgciA9IHBhcnNlSW50KGhleC5zbGljZSgwLCAyKSwgMTYpIC8gMjU1O1xuICBjb25zdCBnID0gcGFyc2VJbnQoaGV4LnNsaWNlKDIsIDQpLCAxNikgLyAyNTU7XG4gIGNvbnN0IGIgPSBwYXJzZUludChoZXguc2xpY2UoNCwgNiksIDE2KSAvIDI1NTtcbiAgY29uc3QgYSA9IHBhcnNlSW50KGhleC5zbGljZSg2LCA4KSwgMTYpIC8gMjU1O1xuICByZXR1cm4gW3IsIGcsIGIsIGFdO1xufVxuZnVuY3Rpb24gcGFyc2VSZ2JhKHJnYmEpIHtcbiAgY29uc3QgbWF0Y2ggPSByZ2JhLm1hdGNoKC9ecmdiYT9cXHMqXFwoXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyosXFxzKihcXGQrKVxccyooPzosXFxzKihbMC05Ll0rKSk/XFxzKlxcKSQvaSk7XG4gIGlmICghbWF0Y2gpIHJldHVybiBbMCwgMCwgMCwgMV07XG4gIHJldHVybiBbXG4gICAgcGFyc2VJbnQobWF0Y2hbMV0gPz8gXCIwXCIpIC8gMjU1LFxuICAgIHBhcnNlSW50KG1hdGNoWzJdID8/IFwiMFwiKSAvIDI1NSxcbiAgICBwYXJzZUludChtYXRjaFszXSA/PyBcIjBcIikgLyAyNTUsXG4gICAgbWF0Y2hbNF0gPT09IHZvaWQgMCA/IDEgOiBwYXJzZUZsb2F0KG1hdGNoWzRdKVxuICBdO1xufVxuZnVuY3Rpb24gcGFyc2VIc2xhKGhzbGEpIHtcbiAgY29uc3QgbWF0Y2ggPSBoc2xhLm1hdGNoKC9eaHNsYT9cXHMqXFwoXFxzKihcXGQrKVxccyosXFxzKihcXGQrKSVcXHMqLFxccyooXFxkKyklXFxzKig/OixcXHMqKFswLTkuXSspKT9cXHMqXFwpJC9pKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIFswLCAwLCAwLCAxXTtcbiAgcmV0dXJuIFtcbiAgICBwYXJzZUludChtYXRjaFsxXSA/PyBcIjBcIiksXG4gICAgcGFyc2VJbnQobWF0Y2hbMl0gPz8gXCIwXCIpLFxuICAgIHBhcnNlSW50KG1hdGNoWzNdID8/IFwiMFwiKSxcbiAgICBtYXRjaFs0XSA9PT0gdm9pZCAwID8gMSA6IHBhcnNlRmxvYXQobWF0Y2hbNF0pXG4gIF07XG59XG5mdW5jdGlvbiBoc2xhVG9SZ2JhKGhzbGEpIHtcbiAgY29uc3QgW2gsIHMsIGwsIGFdID0gaHNsYTtcbiAgY29uc3QgaERlY2ltYWwgPSBoIC8gMzYwO1xuICBjb25zdCBzRGVjaW1hbCA9IHMgLyAxMDA7XG4gIGNvbnN0IGxEZWNpbWFsID0gbCAvIDEwMDtcbiAgbGV0IHIsIGcsIGI7XG4gIGlmIChzID09PSAwKSB7XG4gICAgciA9IGcgPSBiID0gbERlY2ltYWw7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgaHVlMnJnYiA9IChwMiwgcTIsIHQpID0+IHtcbiAgICAgIGlmICh0IDwgMCkgdCArPSAxO1xuICAgICAgaWYgKHQgPiAxKSB0IC09IDE7XG4gICAgICBpZiAodCA8IDEgLyA2KSByZXR1cm4gcDIgKyAocTIgLSBwMikgKiA2ICogdDtcbiAgICAgIGlmICh0IDwgMSAvIDIpIHJldHVybiBxMjtcbiAgICAgIGlmICh0IDwgMiAvIDMpIHJldHVybiBwMiArIChxMiAtIHAyKSAqICgyIC8gMyAtIHQpICogNjtcbiAgICAgIHJldHVybiBwMjtcbiAgICB9O1xuICAgIGNvbnN0IHEgPSBsRGVjaW1hbCA8IDAuNSA/IGxEZWNpbWFsICogKDEgKyBzRGVjaW1hbCkgOiBsRGVjaW1hbCArIHNEZWNpbWFsIC0gbERlY2ltYWwgKiBzRGVjaW1hbDtcbiAgICBjb25zdCBwID0gMiAqIGxEZWNpbWFsIC0gcTtcbiAgICByID0gaHVlMnJnYihwLCBxLCBoRGVjaW1hbCArIDEgLyAzKTtcbiAgICBnID0gaHVlMnJnYihwLCBxLCBoRGVjaW1hbCk7XG4gICAgYiA9IGh1ZTJyZ2IocCwgcSwgaERlY2ltYWwgLSAxIC8gMyk7XG4gIH1cbiAgcmV0dXJuIFtyLCBnLCBiLCBhXTtcbn1cbmNvbnN0IGNsYW1wID0gKG4sIG1pbiwgbWF4KSA9PiBNYXRoLm1pbihNYXRoLm1heChuLCBtaW4pLCBtYXgpO1xuY29uc3QgZmFsbGJhY2tDb2xvciA9IFswLCAwLCAwLCAxXTtcbmV4cG9ydCB7XG4gIGNsYW1wLFxuICBnZXRTaGFkZXJDb2xvckZyb21TdHJpbmdcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtc2hhZGVyLWNvbG9yLWZyb20tc3RyaW5nLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/get-shader-color-from-string.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/shader-mount.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/shader-mount.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShaderMount: () => (/* binding */ ShaderMount),\n/* harmony export */   isPaperShaderElement: () => (/* binding */ isPaperShaderElement)\n/* harmony export */ });\n/* harmony import */ var _vertex_shader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vertex-shader.js */ \"(ssr)/./node_modules/@paper-design/shaders/dist/vertex-shader.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\nconst DEFAULT_MAX_PIXEL_COUNT = 1920 * 1080 * 4;\nclass ShaderMount {\n  parentElement;\n  canvasElement;\n  gl;\n  program = null;\n  uniformLocations = {};\n  /** The fragment shader that we are using */\n  fragmentShader;\n  /** Stores the RAF for the render loop */\n  rafId = null;\n  /** Time of the last rendered frame */\n  lastRenderTime = 0;\n  /** Total time that we have played any animation, passed as a uniform to the shader for time-based VFX */\n  currentFrame = 0;\n  /** The current speed that we progress through animation time (multiplies by delta time every update). Allows negatives to play in reverse. If set to 0, rAF will stop entirely so static shaders have no recurring performance costs */\n  speed = 0;\n  /** Uniforms that are provided by the user for the specific shader being mounted (not including uniforms that this Mount adds, like time and resolution) */\n  providedUniforms;\n  /** Just a sanity check to make sure frames don't run after we're disposed */\n  hasBeenDisposed = false;\n  /** If the resolution of the canvas has changed since the last render */\n  resolutionChanged = true;\n  /** Store textures that are provided by the user */\n  textures = /* @__PURE__ */ new Map();\n  minPixelRatio;\n  maxPixelCount;\n  isSafari = isSafari();\n  uniformCache = {};\n  textureUnitMap = /* @__PURE__ */ new Map();\n  constructor(parentElement, fragmentShader, uniforms, webGlContextAttributes, speed = 0, frame = 0, minPixelRatio = 2, maxPixelCount = DEFAULT_MAX_PIXEL_COUNT) {\n    if (parentElement instanceof HTMLElement) {\n      this.parentElement = parentElement;\n    } else {\n      throw new Error(\"Paper Shaders: parent element must be an HTMLElement\");\n    }\n    if (!document.querySelector(\"style[data-paper-shader]\")) {\n      const styleElement = document.createElement(\"style\");\n      styleElement.innerHTML = defaultStyle;\n      styleElement.setAttribute(\"data-paper-shader\", \"\");\n      document.head.prepend(styleElement);\n    }\n    const canvasElement = document.createElement(\"canvas\");\n    this.canvasElement = canvasElement;\n    this.parentElement.prepend(canvasElement);\n    this.fragmentShader = fragmentShader;\n    this.providedUniforms = uniforms;\n    this.currentFrame = frame;\n    this.minPixelRatio = minPixelRatio;\n    this.maxPixelCount = maxPixelCount;\n    const gl = canvasElement.getContext(\"webgl2\", webGlContextAttributes);\n    if (!gl) {\n      throw new Error(\"Paper Shaders: WebGL is not supported in this browser\");\n    }\n    this.gl = gl;\n    this.initProgram();\n    this.setupPositionAttribute();\n    this.setupUniforms();\n    this.setUniformValues(this.providedUniforms);\n    this.setupResizeObserver();\n    this.setSpeed(speed);\n    this.parentElement.setAttribute(\"data-paper-shader\", \"\");\n    this.parentElement.paperShaderMount = this;\n  }\n  initProgram = () => {\n    const program = createProgram(this.gl, _vertex_shader_js__WEBPACK_IMPORTED_MODULE_0__.vertexShaderSource, this.fragmentShader);\n    if (!program) return;\n    this.program = program;\n  };\n  setupPositionAttribute = () => {\n    const positionAttributeLocation = this.gl.getAttribLocation(this.program, \"a_position\");\n    const positionBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, positionBuffer);\n    const positions = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(positions), this.gl.STATIC_DRAW);\n    this.gl.enableVertexAttribArray(positionAttributeLocation);\n    this.gl.vertexAttribPointer(positionAttributeLocation, 2, this.gl.FLOAT, false, 0, 0);\n  };\n  setupUniforms = () => {\n    const uniformLocations = {\n      u_time: this.gl.getUniformLocation(this.program, \"u_time\"),\n      u_pixelRatio: this.gl.getUniformLocation(this.program, \"u_pixelRatio\"),\n      u_resolution: this.gl.getUniformLocation(this.program, \"u_resolution\")\n    };\n    Object.entries(this.providedUniforms).forEach(([key, value]) => {\n      uniformLocations[key] = this.gl.getUniformLocation(this.program, key);\n      if (value instanceof HTMLImageElement) {\n        const aspectRatioUniformName = `${key}AspectRatio`;\n        uniformLocations[aspectRatioUniformName] = this.gl.getUniformLocation(this.program, aspectRatioUniformName);\n      }\n    });\n    this.uniformLocations = uniformLocations;\n  };\n  /**\n   * The scale that we should render at.\n   * - Used to target 2x rendering even on 1x screens for better antialiasing\n   * - Prevents the virtual resolution from going beyond the maximum resolution\n   * - Accounts for the page zoom level so we render in physical device pixels rather than CSS pixels\n   */\n  renderScale = 1;\n  parentWidth = 0;\n  parentHeight = 0;\n  resizeObserver = null;\n  setupResizeObserver = () => {\n    this.resizeObserver = new ResizeObserver(([entry]) => {\n      if (entry?.borderBoxSize[0]) {\n        this.parentWidth = entry.borderBoxSize[0].inlineSize;\n        this.parentHeight = entry.borderBoxSize[0].blockSize;\n      }\n      this.handleResize();\n    });\n    this.resizeObserver.observe(this.parentElement);\n    visualViewport?.addEventListener(\"resize\", this.handleVisualViewportChange);\n    const rect = this.parentElement.getBoundingClientRect();\n    this.parentWidth = rect.width;\n    this.parentHeight = rect.height;\n    this.handleResize();\n  };\n  // Visual viewport resize handler, mainly used to react to browser zoom changes.\n  // Wait 2 frames to align with when the resize observer callback is done (in case it might follow):\n  // - Frame 1: a paint after the visual viewport resize\n  // - Frame 2: a paint after the resize observer has been handled, if it was ever triggered\n  //\n  // Both resize observer and visual viewport will react to classic browser zoom changes,\n  // so we dedupe the callbacks, but pinch zoom only triggers the visual viewport handler.\n  resizeRafId = null;\n  handleVisualViewportChange = () => {\n    if (this.resizeRafId !== null) {\n      cancelAnimationFrame(this.resizeRafId);\n    }\n    this.resizeRafId = requestAnimationFrame(() => {\n      this.resizeRafId = requestAnimationFrame(() => {\n        this.handleResize();\n      });\n    });\n  };\n  /** Resize handler for when the container div changes size or the max pixel count changes and we want to resize our canvas to match */\n  handleResize = () => {\n    if (this.resizeRafId !== null) {\n      cancelAnimationFrame(this.resizeRafId);\n    }\n    const pinchZoom = visualViewport?.scale ?? 1;\n    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n    const innerWidth = visualViewport ? visualViewport.scale * visualViewport.width + scrollbarWidth : window.innerWidth;\n    const classicZoom = Math.round(1e4 * window.outerWidth / innerWidth) / 1e4;\n    const realPixelRatio = this.isSafari ? devicePixelRatio : devicePixelRatio / classicZoom;\n    const targetPixelRatio = Math.max(realPixelRatio, this.minPixelRatio);\n    const targetRenderScale = targetPixelRatio * classicZoom * pinchZoom;\n    const targetPixelWidth = this.parentWidth * targetRenderScale;\n    const targetPixelHeight = this.parentHeight * targetRenderScale;\n    const maxPixelCountHeadroom = Math.sqrt(this.maxPixelCount) / Math.sqrt(targetPixelWidth * targetPixelHeight);\n    const newRenderScale = targetRenderScale * Math.min(1, maxPixelCountHeadroom);\n    const newWidth = Math.round(this.parentWidth * newRenderScale);\n    const newHeight = Math.round(this.parentHeight * newRenderScale);\n    if (this.canvasElement.width !== newWidth || this.canvasElement.height !== newHeight || this.renderScale !== newRenderScale) {\n      this.renderScale = newRenderScale;\n      this.canvasElement.width = newWidth;\n      this.canvasElement.height = newHeight;\n      this.resolutionChanged = true;\n      this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);\n      this.render(performance.now());\n    }\n  };\n  render = (currentTime) => {\n    if (this.hasBeenDisposed) return;\n    if (this.program === null) {\n      console.warn(\"Tried to render before program or gl was initialized\");\n      return;\n    }\n    const dt = currentTime - this.lastRenderTime;\n    this.lastRenderTime = currentTime;\n    if (this.speed !== 0) {\n      this.currentFrame += dt * this.speed;\n    }\n    this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n    this.gl.useProgram(this.program);\n    this.gl.uniform1f(this.uniformLocations.u_time, this.currentFrame * 1e-3);\n    if (this.resolutionChanged) {\n      this.gl.uniform2f(this.uniformLocations.u_resolution, this.gl.canvas.width, this.gl.canvas.height);\n      this.gl.uniform1f(this.uniformLocations.u_pixelRatio, this.renderScale);\n      this.resolutionChanged = false;\n    }\n    this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);\n    if (this.speed !== 0) {\n      this.requestRender();\n    } else {\n      this.rafId = null;\n    }\n  };\n  requestRender = () => {\n    if (this.rafId !== null) {\n      cancelAnimationFrame(this.rafId);\n    }\n    this.rafId = requestAnimationFrame(this.render);\n  };\n  /** Creates a texture from an image and sets it into a uniform value */\n  setTextureUniform = (uniformName, image) => {\n    if (!image.complete || image.naturalWidth === 0) {\n      throw new Error(`Paper Shaders: image for uniform ${uniformName} must be fully loaded`);\n    }\n    const existingTexture = this.textures.get(uniformName);\n    if (existingTexture) {\n      this.gl.deleteTexture(existingTexture);\n    }\n    if (!this.textureUnitMap.has(uniformName)) {\n      this.textureUnitMap.set(uniformName, this.textureUnitMap.size);\n    }\n    const textureUnit = this.textureUnitMap.get(uniformName);\n    this.gl.activeTexture(this.gl.TEXTURE0 + textureUnit);\n    const texture = this.gl.createTexture();\n    this.gl.bindTexture(this.gl.TEXTURE_2D, texture);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);\n    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);\n    const error = this.gl.getError();\n    if (error !== this.gl.NO_ERROR || texture === null) {\n      console.error(\"Paper Shaders: WebGL error when uploading texture:\", error);\n      return;\n    }\n    this.textures.set(uniformName, texture);\n    const location = this.uniformLocations[uniformName];\n    if (location) {\n      this.gl.uniform1i(location, textureUnit);\n      const aspectRatioUniformName = `${uniformName}AspectRatio`;\n      const aspectRatioLocation = this.uniformLocations[aspectRatioUniformName];\n      if (aspectRatioLocation) {\n        const aspectRatio = image.naturalWidth / image.naturalHeight;\n        this.gl.uniform1f(aspectRatioLocation, aspectRatio);\n      }\n    }\n  };\n  /** Utility: recursive equality test for all the uniforms */\n  areUniformValuesEqual = (a, b) => {\n    if (a === b) return true;\n    if (Array.isArray(a) && Array.isArray(b) && a.length === b.length) {\n      return a.every((val, i) => this.areUniformValuesEqual(val, b[i]));\n    }\n    return false;\n  };\n  /** Sets the provided uniform values into the WebGL program, can be a partial list of uniforms that have changed */\n  setUniformValues = (updatedUniforms) => {\n    this.gl.useProgram(this.program);\n    Object.entries(updatedUniforms).forEach(([key, value]) => {\n      let cacheValue = value;\n      if (value instanceof HTMLImageElement) {\n        cacheValue = `${value.src.slice(0, 200)}|${value.naturalWidth}x${value.naturalHeight}`;\n      }\n      if (this.areUniformValuesEqual(this.uniformCache[key], cacheValue)) return;\n      this.uniformCache[key] = cacheValue;\n      const location = this.uniformLocations[key];\n      if (!location) {\n        console.warn(`Uniform location for ${key} not found`);\n        return;\n      }\n      if (value instanceof HTMLImageElement) {\n        this.setTextureUniform(key, value);\n      } else if (Array.isArray(value)) {\n        let flatArray = null;\n        let valueLength = null;\n        if (value[0] !== void 0 && Array.isArray(value[0])) {\n          const firstChildLength = value[0].length;\n          if (value.every((arr) => arr.length === firstChildLength)) {\n            flatArray = value.flat();\n            valueLength = firstChildLength;\n          } else {\n            console.warn(`All child arrays must be the same length for ${key}`);\n            return;\n          }\n        } else {\n          flatArray = value;\n          valueLength = flatArray.length;\n        }\n        switch (valueLength) {\n          case 2:\n            this.gl.uniform2fv(location, flatArray);\n            break;\n          case 3:\n            this.gl.uniform3fv(location, flatArray);\n            break;\n          case 4:\n            this.gl.uniform4fv(location, flatArray);\n            break;\n          case 9:\n            this.gl.uniformMatrix3fv(location, false, flatArray);\n            break;\n          case 16:\n            this.gl.uniformMatrix4fv(location, false, flatArray);\n            break;\n          default:\n            console.warn(`Unsupported uniform array length: ${valueLength}`);\n        }\n      } else if (typeof value === \"number\") {\n        this.gl.uniform1f(location, value);\n      } else if (typeof value === \"boolean\") {\n        this.gl.uniform1i(location, value ? 1 : 0);\n      } else {\n        console.warn(`Unsupported uniform type for ${key}: ${typeof value}`);\n      }\n    });\n  };\n  /** Gets the current total animation time from 0ms */\n  getCurrentFrame = () => {\n    return this.currentFrame;\n  };\n  /** Set a frame to get a deterministic result, frames are literally just milliseconds from zero since the animation started */\n  setFrame = (newFrame) => {\n    this.currentFrame = newFrame;\n    this.lastRenderTime = performance.now();\n    this.render(performance.now());\n  };\n  /** Set an animation speed (or 0 to stop animation) */\n  setSpeed = (newSpeed = 1) => {\n    this.speed = newSpeed;\n    if (this.rafId === null && newSpeed !== 0) {\n      this.lastRenderTime = performance.now();\n      this.rafId = requestAnimationFrame(this.render);\n    }\n    if (this.rafId !== null && newSpeed === 0) {\n      cancelAnimationFrame(this.rafId);\n      this.rafId = null;\n    }\n  };\n  /** Set the maximum pixel count for the shader, this will limit the number of pixels that will be rendered */\n  setMaxPixelCount = (newMaxPixelCount = DEFAULT_MAX_PIXEL_COUNT) => {\n    this.maxPixelCount = newMaxPixelCount;\n    this.handleResize();\n  };\n  /** Set the minimum pixel ratio for the shader */\n  setMinPixelRatio = (newMinPixelRatio = 2) => {\n    this.minPixelRatio = newMinPixelRatio;\n    this.handleResize();\n  };\n  /** Update the uniforms that are provided by the outside shader, can be a partial set with only the uniforms that have changed */\n  setUniforms = (newUniforms) => {\n    this.setUniformValues(newUniforms);\n    this.providedUniforms = { ...this.providedUniforms, ...newUniforms };\n    this.render(performance.now());\n  };\n  /** Dispose of the shader mount, cleaning up all of the WebGL resources */\n  dispose = () => {\n    this.hasBeenDisposed = true;\n    if (this.rafId !== null) {\n      cancelAnimationFrame(this.rafId);\n      this.rafId = null;\n    }\n    if (this.gl && this.program) {\n      this.textures.forEach((texture) => {\n        this.gl.deleteTexture(texture);\n      });\n      this.textures.clear();\n      this.gl.deleteProgram(this.program);\n      this.program = null;\n      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n      this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, null);\n      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);\n      this.gl.getError();\n    }\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n      this.resizeObserver = null;\n    }\n    visualViewport?.removeEventListener(\"resize\", this.handleVisualViewportChange);\n    this.uniformLocations = {};\n    this.parentElement.paperShaderMount = void 0;\n  };\n}\nfunction createShader(gl, type, source) {\n  const shader = gl.createShader(type);\n  if (!shader) return null;\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    console.error(\"An error occurred compiling the shaders: \" + gl.getShaderInfoLog(shader));\n    gl.deleteShader(shader);\n    return null;\n  }\n  return shader;\n}\nfunction createProgram(gl, vertexShaderSource2, fragmentShaderSource) {\n  const format = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT);\n  const precision = format ? format.precision : null;\n  if (precision && precision < 23) {\n    vertexShaderSource2 = vertexShaderSource2.replace(/precision\\s+(lowp|mediump)\\s+float;/g, \"precision highp float;\");\n    fragmentShaderSource = fragmentShaderSource.replace(/precision\\s+(lowp|mediump)\\s+float/g, \"precision highp float\").replace(/\\b(uniform|varying|attribute)\\s+(lowp|mediump)\\s+(\\w+)/g, \"$1 highp $3\");\n  }\n  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource2);\n  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n  if (!vertexShader || !fragmentShader) return null;\n  const program = gl.createProgram();\n  if (!program) return null;\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.error(\"Unable to initialize the shader program: \" + gl.getProgramInfoLog(program));\n    gl.deleteProgram(program);\n    gl.deleteShader(vertexShader);\n    gl.deleteShader(fragmentShader);\n    return null;\n  }\n  gl.detachShader(program, vertexShader);\n  gl.detachShader(program, fragmentShader);\n  gl.deleteShader(vertexShader);\n  gl.deleteShader(fragmentShader);\n  return program;\n}\nconst defaultStyle = `@layer paper-shaders {\n  :where([data-paper-shader]) {\n    isolation: isolate;\n    position: relative;\n\n    & canvas {\n      contain: strict;\n      display: block;\n      position: absolute;\n      inset: 0;\n      z-index: -1;\n      width: 100%;\n      height: 100%;\n      border-radius: inherit;\n      corner-shape: inherit;\n    }\n  }\n}`;\nfunction isPaperShaderElement(element) {\n  return \"paperShaderMount\" in element;\n}\nfunction isSafari() {\n  const ua = navigator.userAgent.toLowerCase();\n  return ua.includes(\"safari\") && !ua.includes(\"chrome\") && !ua.includes(\"android\");\n}\n\n//# sourceMappingURL=shader-mount.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLW1vdW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUV3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsaUVBQWtCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxJQUFJO0FBQzlDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGFBQWE7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxZQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0IsR0FBRyxtQkFBbUIsR0FBRyxvQkFBb0I7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxLQUFLO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLHlFQUF5RSxJQUFJO0FBQzdFO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxZQUFZO0FBQzFFO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSLHFEQUFxRCxJQUFJLElBQUksYUFBYTtBQUMxRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLDJCQUEyQjtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2ltcmFubW9oYW1tZWQvZGVzaWduLXdpdGgtY2xhdWRlL3dlYi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLW1vdW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiAgICAgICAgICAgICAgICAgICAgUGFwZXIgU2hhZGVycyAgICAgICAgICAgICAgICAgICAgKlxuICogICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3BhcGVyLWRlc2lnbi9zaGFkZXJzICAgICAgICpcbiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuXG5pbXBvcnQgeyB2ZXJ0ZXhTaGFkZXJTb3VyY2UgfSBmcm9tIFwiLi92ZXJ0ZXgtc2hhZGVyLmpzXCI7XG5jb25zdCBERUZBVUxUX01BWF9QSVhFTF9DT1VOVCA9IDE5MjAgKiAxMDgwICogNDtcbmNsYXNzIFNoYWRlck1vdW50IHtcbiAgcGFyZW50RWxlbWVudDtcbiAgY2FudmFzRWxlbWVudDtcbiAgZ2w7XG4gIHByb2dyYW0gPSBudWxsO1xuICB1bmlmb3JtTG9jYXRpb25zID0ge307XG4gIC8qKiBUaGUgZnJhZ21lbnQgc2hhZGVyIHRoYXQgd2UgYXJlIHVzaW5nICovXG4gIGZyYWdtZW50U2hhZGVyO1xuICAvKiogU3RvcmVzIHRoZSBSQUYgZm9yIHRoZSByZW5kZXIgbG9vcCAqL1xuICByYWZJZCA9IG51bGw7XG4gIC8qKiBUaW1lIG9mIHRoZSBsYXN0IHJlbmRlcmVkIGZyYW1lICovXG4gIGxhc3RSZW5kZXJUaW1lID0gMDtcbiAgLyoqIFRvdGFsIHRpbWUgdGhhdCB3ZSBoYXZlIHBsYXllZCBhbnkgYW5pbWF0aW9uLCBwYXNzZWQgYXMgYSB1bmlmb3JtIHRvIHRoZSBzaGFkZXIgZm9yIHRpbWUtYmFzZWQgVkZYICovXG4gIGN1cnJlbnRGcmFtZSA9IDA7XG4gIC8qKiBUaGUgY3VycmVudCBzcGVlZCB0aGF0IHdlIHByb2dyZXNzIHRocm91Z2ggYW5pbWF0aW9uIHRpbWUgKG11bHRpcGxpZXMgYnkgZGVsdGEgdGltZSBldmVyeSB1cGRhdGUpLiBBbGxvd3MgbmVnYXRpdmVzIHRvIHBsYXkgaW4gcmV2ZXJzZS4gSWYgc2V0IHRvIDAsIHJBRiB3aWxsIHN0b3AgZW50aXJlbHkgc28gc3RhdGljIHNoYWRlcnMgaGF2ZSBubyByZWN1cnJpbmcgcGVyZm9ybWFuY2UgY29zdHMgKi9cbiAgc3BlZWQgPSAwO1xuICAvKiogVW5pZm9ybXMgdGhhdCBhcmUgcHJvdmlkZWQgYnkgdGhlIHVzZXIgZm9yIHRoZSBzcGVjaWZpYyBzaGFkZXIgYmVpbmcgbW91bnRlZCAobm90IGluY2x1ZGluZyB1bmlmb3JtcyB0aGF0IHRoaXMgTW91bnQgYWRkcywgbGlrZSB0aW1lIGFuZCByZXNvbHV0aW9uKSAqL1xuICBwcm92aWRlZFVuaWZvcm1zO1xuICAvKiogSnVzdCBhIHNhbml0eSBjaGVjayB0byBtYWtlIHN1cmUgZnJhbWVzIGRvbid0IHJ1biBhZnRlciB3ZSdyZSBkaXNwb3NlZCAqL1xuICBoYXNCZWVuRGlzcG9zZWQgPSBmYWxzZTtcbiAgLyoqIElmIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBjYW52YXMgaGFzIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgcmVuZGVyICovXG4gIHJlc29sdXRpb25DaGFuZ2VkID0gdHJ1ZTtcbiAgLyoqIFN0b3JlIHRleHR1cmVzIHRoYXQgYXJlIHByb3ZpZGVkIGJ5IHRoZSB1c2VyICovXG4gIHRleHR1cmVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbWluUGl4ZWxSYXRpbztcbiAgbWF4UGl4ZWxDb3VudDtcbiAgaXNTYWZhcmkgPSBpc1NhZmFyaSgpO1xuICB1bmlmb3JtQ2FjaGUgPSB7fTtcbiAgdGV4dHVyZVVuaXRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdHJ1Y3RvcihwYXJlbnRFbGVtZW50LCBmcmFnbWVudFNoYWRlciwgdW5pZm9ybXMsIHdlYkdsQ29udGV4dEF0dHJpYnV0ZXMsIHNwZWVkID0gMCwgZnJhbWUgPSAwLCBtaW5QaXhlbFJhdGlvID0gMiwgbWF4UGl4ZWxDb3VudCA9IERFRkFVTFRfTUFYX1BJWEVMX0NPVU5UKSB7XG4gICAgaWYgKHBhcmVudEVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgdGhpcy5wYXJlbnRFbGVtZW50ID0gcGFyZW50RWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFwZXIgU2hhZGVyczogcGFyZW50IGVsZW1lbnQgbXVzdCBiZSBhbiBIVE1MRWxlbWVudFwiKTtcbiAgICB9XG4gICAgaWYgKCFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwic3R5bGVbZGF0YS1wYXBlci1zaGFkZXJdXCIpKSB7XG4gICAgICBjb25zdCBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICBzdHlsZUVsZW1lbnQuaW5uZXJIVE1MID0gZGVmYXVsdFN0eWxlO1xuICAgICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtcGFwZXItc2hhZGVyXCIsIFwiXCIpO1xuICAgICAgZG9jdW1lbnQuaGVhZC5wcmVwZW5kKHN0eWxlRWxlbWVudCk7XG4gICAgfVxuICAgIGNvbnN0IGNhbnZhc0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIHRoaXMuY2FudmFzRWxlbWVudCA9IGNhbnZhc0VsZW1lbnQ7XG4gICAgdGhpcy5wYXJlbnRFbGVtZW50LnByZXBlbmQoY2FudmFzRWxlbWVudCk7XG4gICAgdGhpcy5mcmFnbWVudFNoYWRlciA9IGZyYWdtZW50U2hhZGVyO1xuICAgIHRoaXMucHJvdmlkZWRVbmlmb3JtcyA9IHVuaWZvcm1zO1xuICAgIHRoaXMuY3VycmVudEZyYW1lID0gZnJhbWU7XG4gICAgdGhpcy5taW5QaXhlbFJhdGlvID0gbWluUGl4ZWxSYXRpbztcbiAgICB0aGlzLm1heFBpeGVsQ291bnQgPSBtYXhQaXhlbENvdW50O1xuICAgIGNvbnN0IGdsID0gY2FudmFzRWxlbWVudC5nZXRDb250ZXh0KFwid2ViZ2wyXCIsIHdlYkdsQ29udGV4dEF0dHJpYnV0ZXMpO1xuICAgIGlmICghZ2wpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcGVyIFNoYWRlcnM6IFdlYkdMIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyXCIpO1xuICAgIH1cbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgdGhpcy5pbml0UHJvZ3JhbSgpO1xuICAgIHRoaXMuc2V0dXBQb3NpdGlvbkF0dHJpYnV0ZSgpO1xuICAgIHRoaXMuc2V0dXBVbmlmb3JtcygpO1xuICAgIHRoaXMuc2V0VW5pZm9ybVZhbHVlcyh0aGlzLnByb3ZpZGVkVW5pZm9ybXMpO1xuICAgIHRoaXMuc2V0dXBSZXNpemVPYnNlcnZlcigpO1xuICAgIHRoaXMuc2V0U3BlZWQoc3BlZWQpO1xuICAgIHRoaXMucGFyZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBhcGVyLXNoYWRlclwiLCBcIlwiKTtcbiAgICB0aGlzLnBhcmVudEVsZW1lbnQucGFwZXJTaGFkZXJNb3VudCA9IHRoaXM7XG4gIH1cbiAgaW5pdFByb2dyYW0gPSAoKSA9PiB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW0odGhpcy5nbCwgdmVydGV4U2hhZGVyU291cmNlLCB0aGlzLmZyYWdtZW50U2hhZGVyKTtcbiAgICBpZiAoIXByb2dyYW0pIHJldHVybjtcbiAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xuICB9O1xuICBzZXR1cFBvc2l0aW9uQXR0cmlidXRlID0gKCkgPT4ge1xuICAgIGNvbnN0IHBvc2l0aW9uQXR0cmlidXRlTG9jYXRpb24gPSB0aGlzLmdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgXCJhX3Bvc2l0aW9uXCIpO1xuICAgIGNvbnN0IHBvc2l0aW9uQnVmZmVyID0gdGhpcy5nbC5jcmVhdGVCdWZmZXIoKTtcbiAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsIHBvc2l0aW9uQnVmZmVyKTtcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBbLTEsIC0xLCAxLCAtMSwgLTEsIDEsIC0xLCAxLCAxLCAtMSwgMSwgMV07XG4gICAgdGhpcy5nbC5idWZmZXJEYXRhKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9ucyksIHRoaXMuZ2wuU1RBVElDX0RSQVcpO1xuICAgIHRoaXMuZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25BdHRyaWJ1dGVMb2NhdGlvbik7XG4gICAgdGhpcy5nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBvc2l0aW9uQXR0cmlidXRlTG9jYXRpb24sIDIsIHRoaXMuZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgfTtcbiAgc2V0dXBVbmlmb3JtcyA9ICgpID0+IHtcbiAgICBjb25zdCB1bmlmb3JtTG9jYXRpb25zID0ge1xuICAgICAgdV90aW1lOiB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIFwidV90aW1lXCIpLFxuICAgICAgdV9waXhlbFJhdGlvOiB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIFwidV9waXhlbFJhdGlvXCIpLFxuICAgICAgdV9yZXNvbHV0aW9uOiB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIFwidV9yZXNvbHV0aW9uXCIpXG4gICAgfTtcbiAgICBPYmplY3QuZW50cmllcyh0aGlzLnByb3ZpZGVkVW5pZm9ybXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgdW5pZm9ybUxvY2F0aW9uc1trZXldID0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBrZXkpO1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkge1xuICAgICAgICBjb25zdCBhc3BlY3RSYXRpb1VuaWZvcm1OYW1lID0gYCR7a2V5fUFzcGVjdFJhdGlvYDtcbiAgICAgICAgdW5pZm9ybUxvY2F0aW9uc1thc3BlY3RSYXRpb1VuaWZvcm1OYW1lXSA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgYXNwZWN0UmF0aW9Vbmlmb3JtTmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy51bmlmb3JtTG9jYXRpb25zID0gdW5pZm9ybUxvY2F0aW9ucztcbiAgfTtcbiAgLyoqXG4gICAqIFRoZSBzY2FsZSB0aGF0IHdlIHNob3VsZCByZW5kZXIgYXQuXG4gICAqIC0gVXNlZCB0byB0YXJnZXQgMnggcmVuZGVyaW5nIGV2ZW4gb24gMXggc2NyZWVucyBmb3IgYmV0dGVyIGFudGlhbGlhc2luZ1xuICAgKiAtIFByZXZlbnRzIHRoZSB2aXJ0dWFsIHJlc29sdXRpb24gZnJvbSBnb2luZyBiZXlvbmQgdGhlIG1heGltdW0gcmVzb2x1dGlvblxuICAgKiAtIEFjY291bnRzIGZvciB0aGUgcGFnZSB6b29tIGxldmVsIHNvIHdlIHJlbmRlciBpbiBwaHlzaWNhbCBkZXZpY2UgcGl4ZWxzIHJhdGhlciB0aGFuIENTUyBwaXhlbHNcbiAgICovXG4gIHJlbmRlclNjYWxlID0gMTtcbiAgcGFyZW50V2lkdGggPSAwO1xuICBwYXJlbnRIZWlnaHQgPSAwO1xuICByZXNpemVPYnNlcnZlciA9IG51bGw7XG4gIHNldHVwUmVzaXplT2JzZXJ2ZXIgPSAoKSA9PiB7XG4gICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoW2VudHJ5XSkgPT4ge1xuICAgICAgaWYgKGVudHJ5Py5ib3JkZXJCb3hTaXplWzBdKSB7XG4gICAgICAgIHRoaXMucGFyZW50V2lkdGggPSBlbnRyeS5ib3JkZXJCb3hTaXplWzBdLmlubGluZVNpemU7XG4gICAgICAgIHRoaXMucGFyZW50SGVpZ2h0ID0gZW50cnkuYm9yZGVyQm94U2l6ZVswXS5ibG9ja1NpemU7XG4gICAgICB9XG4gICAgICB0aGlzLmhhbmRsZVJlc2l6ZSgpO1xuICAgIH0pO1xuICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLnBhcmVudEVsZW1lbnQpO1xuICAgIHZpc3VhbFZpZXdwb3J0Py5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMuaGFuZGxlVmlzdWFsVmlld3BvcnRDaGFuZ2UpO1xuICAgIGNvbnN0IHJlY3QgPSB0aGlzLnBhcmVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdGhpcy5wYXJlbnRXaWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgdGhpcy5wYXJlbnRIZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgICB0aGlzLmhhbmRsZVJlc2l6ZSgpO1xuICB9O1xuICAvLyBWaXN1YWwgdmlld3BvcnQgcmVzaXplIGhhbmRsZXIsIG1haW5seSB1c2VkIHRvIHJlYWN0IHRvIGJyb3dzZXIgem9vbSBjaGFuZ2VzLlxuICAvLyBXYWl0IDIgZnJhbWVzIHRvIGFsaWduIHdpdGggd2hlbiB0aGUgcmVzaXplIG9ic2VydmVyIGNhbGxiYWNrIGlzIGRvbmUgKGluIGNhc2UgaXQgbWlnaHQgZm9sbG93KTpcbiAgLy8gLSBGcmFtZSAxOiBhIHBhaW50IGFmdGVyIHRoZSB2aXN1YWwgdmlld3BvcnQgcmVzaXplXG4gIC8vIC0gRnJhbWUgMjogYSBwYWludCBhZnRlciB0aGUgcmVzaXplIG9ic2VydmVyIGhhcyBiZWVuIGhhbmRsZWQsIGlmIGl0IHdhcyBldmVyIHRyaWdnZXJlZFxuICAvL1xuICAvLyBCb3RoIHJlc2l6ZSBvYnNlcnZlciBhbmQgdmlzdWFsIHZpZXdwb3J0IHdpbGwgcmVhY3QgdG8gY2xhc3NpYyBicm93c2VyIHpvb20gY2hhbmdlcyxcbiAgLy8gc28gd2UgZGVkdXBlIHRoZSBjYWxsYmFja3MsIGJ1dCBwaW5jaCB6b29tIG9ubHkgdHJpZ2dlcnMgdGhlIHZpc3VhbCB2aWV3cG9ydCBoYW5kbGVyLlxuICByZXNpemVSYWZJZCA9IG51bGw7XG4gIGhhbmRsZVZpc3VhbFZpZXdwb3J0Q2hhbmdlID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLnJlc2l6ZVJhZklkICE9PSBudWxsKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJlc2l6ZVJhZklkKTtcbiAgICB9XG4gICAgdGhpcy5yZXNpemVSYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLnJlc2l6ZVJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgdGhpcy5oYW5kbGVSZXNpemUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICAvKiogUmVzaXplIGhhbmRsZXIgZm9yIHdoZW4gdGhlIGNvbnRhaW5lciBkaXYgY2hhbmdlcyBzaXplIG9yIHRoZSBtYXggcGl4ZWwgY291bnQgY2hhbmdlcyBhbmQgd2Ugd2FudCB0byByZXNpemUgb3VyIGNhbnZhcyB0byBtYXRjaCAqL1xuICBoYW5kbGVSZXNpemUgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMucmVzaXplUmFmSWQgIT09IG51bGwpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmVzaXplUmFmSWQpO1xuICAgIH1cbiAgICBjb25zdCBwaW5jaFpvb20gPSB2aXN1YWxWaWV3cG9ydD8uc2NhbGUgPz8gMTtcbiAgICBjb25zdCBzY3JvbGxiYXJXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoIC0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgIGNvbnN0IGlubmVyV2lkdGggPSB2aXN1YWxWaWV3cG9ydCA/IHZpc3VhbFZpZXdwb3J0LnNjYWxlICogdmlzdWFsVmlld3BvcnQud2lkdGggKyBzY3JvbGxiYXJXaWR0aCA6IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIGNvbnN0IGNsYXNzaWNab29tID0gTWF0aC5yb3VuZCgxZTQgKiB3aW5kb3cub3V0ZXJXaWR0aCAvIGlubmVyV2lkdGgpIC8gMWU0O1xuICAgIGNvbnN0IHJlYWxQaXhlbFJhdGlvID0gdGhpcy5pc1NhZmFyaSA/IGRldmljZVBpeGVsUmF0aW8gOiBkZXZpY2VQaXhlbFJhdGlvIC8gY2xhc3NpY1pvb207XG4gICAgY29uc3QgdGFyZ2V0UGl4ZWxSYXRpbyA9IE1hdGgubWF4KHJlYWxQaXhlbFJhdGlvLCB0aGlzLm1pblBpeGVsUmF0aW8pO1xuICAgIGNvbnN0IHRhcmdldFJlbmRlclNjYWxlID0gdGFyZ2V0UGl4ZWxSYXRpbyAqIGNsYXNzaWNab29tICogcGluY2hab29tO1xuICAgIGNvbnN0IHRhcmdldFBpeGVsV2lkdGggPSB0aGlzLnBhcmVudFdpZHRoICogdGFyZ2V0UmVuZGVyU2NhbGU7XG4gICAgY29uc3QgdGFyZ2V0UGl4ZWxIZWlnaHQgPSB0aGlzLnBhcmVudEhlaWdodCAqIHRhcmdldFJlbmRlclNjYWxlO1xuICAgIGNvbnN0IG1heFBpeGVsQ291bnRIZWFkcm9vbSA9IE1hdGguc3FydCh0aGlzLm1heFBpeGVsQ291bnQpIC8gTWF0aC5zcXJ0KHRhcmdldFBpeGVsV2lkdGggKiB0YXJnZXRQaXhlbEhlaWdodCk7XG4gICAgY29uc3QgbmV3UmVuZGVyU2NhbGUgPSB0YXJnZXRSZW5kZXJTY2FsZSAqIE1hdGgubWluKDEsIG1heFBpeGVsQ291bnRIZWFkcm9vbSk7XG4gICAgY29uc3QgbmV3V2lkdGggPSBNYXRoLnJvdW5kKHRoaXMucGFyZW50V2lkdGggKiBuZXdSZW5kZXJTY2FsZSk7XG4gICAgY29uc3QgbmV3SGVpZ2h0ID0gTWF0aC5yb3VuZCh0aGlzLnBhcmVudEhlaWdodCAqIG5ld1JlbmRlclNjYWxlKTtcbiAgICBpZiAodGhpcy5jYW52YXNFbGVtZW50LndpZHRoICE9PSBuZXdXaWR0aCB8fCB0aGlzLmNhbnZhc0VsZW1lbnQuaGVpZ2h0ICE9PSBuZXdIZWlnaHQgfHwgdGhpcy5yZW5kZXJTY2FsZSAhPT0gbmV3UmVuZGVyU2NhbGUpIHtcbiAgICAgIHRoaXMucmVuZGVyU2NhbGUgPSBuZXdSZW5kZXJTY2FsZTtcbiAgICAgIHRoaXMuY2FudmFzRWxlbWVudC53aWR0aCA9IG5ld1dpZHRoO1xuICAgICAgdGhpcy5jYW52YXNFbGVtZW50LmhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgIHRoaXMucmVzb2x1dGlvbkNoYW5nZWQgPSB0cnVlO1xuICAgICAgdGhpcy5nbC52aWV3cG9ydCgwLCAwLCB0aGlzLmdsLmNhbnZhcy53aWR0aCwgdGhpcy5nbC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgIHRoaXMucmVuZGVyKHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICB9XG4gIH07XG4gIHJlbmRlciA9IChjdXJyZW50VGltZSkgPT4ge1xuICAgIGlmICh0aGlzLmhhc0JlZW5EaXNwb3NlZCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLnByb2dyYW0gPT09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlRyaWVkIHRvIHJlbmRlciBiZWZvcmUgcHJvZ3JhbSBvciBnbCB3YXMgaW5pdGlhbGl6ZWRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGR0ID0gY3VycmVudFRpbWUgLSB0aGlzLmxhc3RSZW5kZXJUaW1lO1xuICAgIHRoaXMubGFzdFJlbmRlclRpbWUgPSBjdXJyZW50VGltZTtcbiAgICBpZiAodGhpcy5zcGVlZCAhPT0gMCkge1xuICAgICAgdGhpcy5jdXJyZW50RnJhbWUgKz0gZHQgKiB0aGlzLnNwZWVkO1xuICAgIH1cbiAgICB0aGlzLmdsLmNsZWFyKHRoaXMuZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgdGhpcy5nbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG4gICAgdGhpcy5nbC51bmlmb3JtMWYodGhpcy51bmlmb3JtTG9jYXRpb25zLnVfdGltZSwgdGhpcy5jdXJyZW50RnJhbWUgKiAxZS0zKTtcbiAgICBpZiAodGhpcy5yZXNvbHV0aW9uQ2hhbmdlZCkge1xuICAgICAgdGhpcy5nbC51bmlmb3JtMmYodGhpcy51bmlmb3JtTG9jYXRpb25zLnVfcmVzb2x1dGlvbiwgdGhpcy5nbC5jYW52YXMud2lkdGgsIHRoaXMuZ2wuY2FudmFzLmhlaWdodCk7XG4gICAgICB0aGlzLmdsLnVuaWZvcm0xZih0aGlzLnVuaWZvcm1Mb2NhdGlvbnMudV9waXhlbFJhdGlvLCB0aGlzLnJlbmRlclNjYWxlKTtcbiAgICAgIHRoaXMucmVzb2x1dGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5nbC5kcmF3QXJyYXlzKHRoaXMuZ2wuVFJJQU5HTEVTLCAwLCA2KTtcbiAgICBpZiAodGhpcy5zcGVlZCAhPT0gMCkge1xuICAgICAgdGhpcy5yZXF1ZXN0UmVuZGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmFmSWQgPSBudWxsO1xuICAgIH1cbiAgfTtcbiAgcmVxdWVzdFJlbmRlciA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5yYWZJZCAhPT0gbnVsbCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yYWZJZCk7XG4gICAgfVxuICAgIHRoaXMucmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5yZW5kZXIpO1xuICB9O1xuICAvKiogQ3JlYXRlcyBhIHRleHR1cmUgZnJvbSBhbiBpbWFnZSBhbmQgc2V0cyBpdCBpbnRvIGEgdW5pZm9ybSB2YWx1ZSAqL1xuICBzZXRUZXh0dXJlVW5pZm9ybSA9ICh1bmlmb3JtTmFtZSwgaW1hZ2UpID0+IHtcbiAgICBpZiAoIWltYWdlLmNvbXBsZXRlIHx8IGltYWdlLm5hdHVyYWxXaWR0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXBlciBTaGFkZXJzOiBpbWFnZSBmb3IgdW5pZm9ybSAke3VuaWZvcm1OYW1lfSBtdXN0IGJlIGZ1bGx5IGxvYWRlZGApO1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ1RleHR1cmUgPSB0aGlzLnRleHR1cmVzLmdldCh1bmlmb3JtTmFtZSk7XG4gICAgaWYgKGV4aXN0aW5nVGV4dHVyZSkge1xuICAgICAgdGhpcy5nbC5kZWxldGVUZXh0dXJlKGV4aXN0aW5nVGV4dHVyZSk7XG4gICAgfVxuICAgIGlmICghdGhpcy50ZXh0dXJlVW5pdE1hcC5oYXModW5pZm9ybU5hbWUpKSB7XG4gICAgICB0aGlzLnRleHR1cmVVbml0TWFwLnNldCh1bmlmb3JtTmFtZSwgdGhpcy50ZXh0dXJlVW5pdE1hcC5zaXplKTtcbiAgICB9XG4gICAgY29uc3QgdGV4dHVyZVVuaXQgPSB0aGlzLnRleHR1cmVVbml0TWFwLmdldCh1bmlmb3JtTmFtZSk7XG4gICAgdGhpcy5nbC5hY3RpdmVUZXh0dXJlKHRoaXMuZ2wuVEVYVFVSRTAgKyB0ZXh0dXJlVW5pdCk7XG4gICAgY29uc3QgdGV4dHVyZSA9IHRoaXMuZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy5nbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfV1JBUF9TLCB0aGlzLmdsLkNMQU1QX1RPX0VER0UpO1xuICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9XUkFQX1QsIHRoaXMuZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbC5URVhUVVJFX01JTl9GSUxURVIsIHRoaXMuZ2wuTElORUFSKTtcbiAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGhpcy5nbC5MSU5FQVIpO1xuICAgIHRoaXMuZ2wudGV4SW1hZ2UyRCh0aGlzLmdsLlRFWFRVUkVfMkQsIDAsIHRoaXMuZ2wuUkdCQSwgdGhpcy5nbC5SR0JBLCB0aGlzLmdsLlVOU0lHTkVEX0JZVEUsIGltYWdlKTtcbiAgICBjb25zdCBlcnJvciA9IHRoaXMuZ2wuZ2V0RXJyb3IoKTtcbiAgICBpZiAoZXJyb3IgIT09IHRoaXMuZ2wuTk9fRVJST1IgfHwgdGV4dHVyZSA9PT0gbnVsbCkge1xuICAgICAgY29uc29sZS5lcnJvcihcIlBhcGVyIFNoYWRlcnM6IFdlYkdMIGVycm9yIHdoZW4gdXBsb2FkaW5nIHRleHR1cmU6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy50ZXh0dXJlcy5zZXQodW5pZm9ybU5hbWUsIHRleHR1cmUpO1xuICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy51bmlmb3JtTG9jYXRpb25zW3VuaWZvcm1OYW1lXTtcbiAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgIHRoaXMuZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB0ZXh0dXJlVW5pdCk7XG4gICAgICBjb25zdCBhc3BlY3RSYXRpb1VuaWZvcm1OYW1lID0gYCR7dW5pZm9ybU5hbWV9QXNwZWN0UmF0aW9gO1xuICAgICAgY29uc3QgYXNwZWN0UmF0aW9Mb2NhdGlvbiA9IHRoaXMudW5pZm9ybUxvY2F0aW9uc1thc3BlY3RSYXRpb1VuaWZvcm1OYW1lXTtcbiAgICAgIGlmIChhc3BlY3RSYXRpb0xvY2F0aW9uKSB7XG4gICAgICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gaW1hZ2UubmF0dXJhbFdpZHRoIC8gaW1hZ2UubmF0dXJhbEhlaWdodDtcbiAgICAgICAgdGhpcy5nbC51bmlmb3JtMWYoYXNwZWN0UmF0aW9Mb2NhdGlvbiwgYXNwZWN0UmF0aW8pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyoqIFV0aWxpdHk6IHJlY3Vyc2l2ZSBlcXVhbGl0eSB0ZXN0IGZvciBhbGwgdGhlIHVuaWZvcm1zICovXG4gIGFyZVVuaWZvcm1WYWx1ZXNFcXVhbCA9IChhLCBiKSA9PiB7XG4gICAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpICYmIEFycmF5LmlzQXJyYXkoYikgJiYgYS5sZW5ndGggPT09IGIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYS5ldmVyeSgodmFsLCBpKSA9PiB0aGlzLmFyZVVuaWZvcm1WYWx1ZXNFcXVhbCh2YWwsIGJbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICAvKiogU2V0cyB0aGUgcHJvdmlkZWQgdW5pZm9ybSB2YWx1ZXMgaW50byB0aGUgV2ViR0wgcHJvZ3JhbSwgY2FuIGJlIGEgcGFydGlhbCBsaXN0IG9mIHVuaWZvcm1zIHRoYXQgaGF2ZSBjaGFuZ2VkICovXG4gIHNldFVuaWZvcm1WYWx1ZXMgPSAodXBkYXRlZFVuaWZvcm1zKSA9PiB7XG4gICAgdGhpcy5nbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG4gICAgT2JqZWN0LmVudHJpZXModXBkYXRlZFVuaWZvcm1zKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGxldCBjYWNoZVZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XG4gICAgICAgIGNhY2hlVmFsdWUgPSBgJHt2YWx1ZS5zcmMuc2xpY2UoMCwgMjAwKX18JHt2YWx1ZS5uYXR1cmFsV2lkdGh9eCR7dmFsdWUubmF0dXJhbEhlaWdodH1gO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYXJlVW5pZm9ybVZhbHVlc0VxdWFsKHRoaXMudW5pZm9ybUNhY2hlW2tleV0sIGNhY2hlVmFsdWUpKSByZXR1cm47XG4gICAgICB0aGlzLnVuaWZvcm1DYWNoZVtrZXldID0gY2FjaGVWYWx1ZTtcbiAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy51bmlmb3JtTG9jYXRpb25zW2tleV07XG4gICAgICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgVW5pZm9ybSBsb2NhdGlvbiBmb3IgJHtrZXl9IG5vdCBmb3VuZGApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuc2V0VGV4dHVyZVVuaWZvcm0oa2V5LCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGxldCBmbGF0QXJyYXkgPSBudWxsO1xuICAgICAgICBsZXQgdmFsdWVMZW5ndGggPSBudWxsO1xuICAgICAgICBpZiAodmFsdWVbMF0gIT09IHZvaWQgMCAmJiBBcnJheS5pc0FycmF5KHZhbHVlWzBdKSkge1xuICAgICAgICAgIGNvbnN0IGZpcnN0Q2hpbGRMZW5ndGggPSB2YWx1ZVswXS5sZW5ndGg7XG4gICAgICAgICAgaWYgKHZhbHVlLmV2ZXJ5KChhcnIpID0+IGFyci5sZW5ndGggPT09IGZpcnN0Q2hpbGRMZW5ndGgpKSB7XG4gICAgICAgICAgICBmbGF0QXJyYXkgPSB2YWx1ZS5mbGF0KCk7XG4gICAgICAgICAgICB2YWx1ZUxlbmd0aCA9IGZpcnN0Q2hpbGRMZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgQWxsIGNoaWxkIGFycmF5cyBtdXN0IGJlIHRoZSBzYW1lIGxlbmd0aCBmb3IgJHtrZXl9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZsYXRBcnJheSA9IHZhbHVlO1xuICAgICAgICAgIHZhbHVlTGVuZ3RoID0gZmxhdEFycmF5Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHZhbHVlTGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdGhpcy5nbC51bmlmb3JtMmZ2KGxvY2F0aW9uLCBmbGF0QXJyYXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgdGhpcy5nbC51bmlmb3JtM2Z2KGxvY2F0aW9uLCBmbGF0QXJyYXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgdGhpcy5nbC51bmlmb3JtNGZ2KGxvY2F0aW9uLCBmbGF0QXJyYXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgdGhpcy5nbC51bmlmb3JtTWF0cml4M2Z2KGxvY2F0aW9uLCBmYWxzZSwgZmxhdEFycmF5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICB0aGlzLmdsLnVuaWZvcm1NYXRyaXg0ZnYobG9jYXRpb24sIGZhbHNlLCBmbGF0QXJyYXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgVW5zdXBwb3J0ZWQgdW5pZm9ybSBhcnJheSBsZW5ndGg6ICR7dmFsdWVMZW5ndGh9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRoaXMuZ2wudW5pZm9ybTFmKGxvY2F0aW9uLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgdGhpcy5nbC51bmlmb3JtMWkobG9jYXRpb24sIHZhbHVlID8gMSA6IDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBVbnN1cHBvcnRlZCB1bmlmb3JtIHR5cGUgZm9yICR7a2V5fTogJHt0eXBlb2YgdmFsdWV9YCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIC8qKiBHZXRzIHRoZSBjdXJyZW50IHRvdGFsIGFuaW1hdGlvbiB0aW1lIGZyb20gMG1zICovXG4gIGdldEN1cnJlbnRGcmFtZSA9ICgpID0+IHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50RnJhbWU7XG4gIH07XG4gIC8qKiBTZXQgYSBmcmFtZSB0byBnZXQgYSBkZXRlcm1pbmlzdGljIHJlc3VsdCwgZnJhbWVzIGFyZSBsaXRlcmFsbHkganVzdCBtaWxsaXNlY29uZHMgZnJvbSB6ZXJvIHNpbmNlIHRoZSBhbmltYXRpb24gc3RhcnRlZCAqL1xuICBzZXRGcmFtZSA9IChuZXdGcmFtZSkgPT4ge1xuICAgIHRoaXMuY3VycmVudEZyYW1lID0gbmV3RnJhbWU7XG4gICAgdGhpcy5sYXN0UmVuZGVyVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHRoaXMucmVuZGVyKHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgfTtcbiAgLyoqIFNldCBhbiBhbmltYXRpb24gc3BlZWQgKG9yIDAgdG8gc3RvcCBhbmltYXRpb24pICovXG4gIHNldFNwZWVkID0gKG5ld1NwZWVkID0gMSkgPT4ge1xuICAgIHRoaXMuc3BlZWQgPSBuZXdTcGVlZDtcbiAgICBpZiAodGhpcy5yYWZJZCA9PT0gbnVsbCAmJiBuZXdTcGVlZCAhPT0gMCkge1xuICAgICAgdGhpcy5sYXN0UmVuZGVyVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgdGhpcy5yYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnJlbmRlcik7XG4gICAgfVxuICAgIGlmICh0aGlzLnJhZklkICE9PSBudWxsICYmIG5ld1NwZWVkID09PSAwKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJhZklkKTtcbiAgICAgIHRoaXMucmFmSWQgPSBudWxsO1xuICAgIH1cbiAgfTtcbiAgLyoqIFNldCB0aGUgbWF4aW11bSBwaXhlbCBjb3VudCBmb3IgdGhlIHNoYWRlciwgdGhpcyB3aWxsIGxpbWl0IHRoZSBudW1iZXIgb2YgcGl4ZWxzIHRoYXQgd2lsbCBiZSByZW5kZXJlZCAqL1xuICBzZXRNYXhQaXhlbENvdW50ID0gKG5ld01heFBpeGVsQ291bnQgPSBERUZBVUxUX01BWF9QSVhFTF9DT1VOVCkgPT4ge1xuICAgIHRoaXMubWF4UGl4ZWxDb3VudCA9IG5ld01heFBpeGVsQ291bnQ7XG4gICAgdGhpcy5oYW5kbGVSZXNpemUoKTtcbiAgfTtcbiAgLyoqIFNldCB0aGUgbWluaW11bSBwaXhlbCByYXRpbyBmb3IgdGhlIHNoYWRlciAqL1xuICBzZXRNaW5QaXhlbFJhdGlvID0gKG5ld01pblBpeGVsUmF0aW8gPSAyKSA9PiB7XG4gICAgdGhpcy5taW5QaXhlbFJhdGlvID0gbmV3TWluUGl4ZWxSYXRpbztcbiAgICB0aGlzLmhhbmRsZVJlc2l6ZSgpO1xuICB9O1xuICAvKiogVXBkYXRlIHRoZSB1bmlmb3JtcyB0aGF0IGFyZSBwcm92aWRlZCBieSB0aGUgb3V0c2lkZSBzaGFkZXIsIGNhbiBiZSBhIHBhcnRpYWwgc2V0IHdpdGggb25seSB0aGUgdW5pZm9ybXMgdGhhdCBoYXZlIGNoYW5nZWQgKi9cbiAgc2V0VW5pZm9ybXMgPSAobmV3VW5pZm9ybXMpID0+IHtcbiAgICB0aGlzLnNldFVuaWZvcm1WYWx1ZXMobmV3VW5pZm9ybXMpO1xuICAgIHRoaXMucHJvdmlkZWRVbmlmb3JtcyA9IHsgLi4udGhpcy5wcm92aWRlZFVuaWZvcm1zLCAuLi5uZXdVbmlmb3JtcyB9O1xuICAgIHRoaXMucmVuZGVyKHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgfTtcbiAgLyoqIERpc3Bvc2Ugb2YgdGhlIHNoYWRlciBtb3VudCwgY2xlYW5pbmcgdXAgYWxsIG9mIHRoZSBXZWJHTCByZXNvdXJjZXMgKi9cbiAgZGlzcG9zZSA9ICgpID0+IHtcbiAgICB0aGlzLmhhc0JlZW5EaXNwb3NlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMucmFmSWQgIT09IG51bGwpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmFmSWQpO1xuICAgICAgdGhpcy5yYWZJZCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmdsICYmIHRoaXMucHJvZ3JhbSkge1xuICAgICAgdGhpcy50ZXh0dXJlcy5mb3JFYWNoKCh0ZXh0dXJlKSA9PiB7XG4gICAgICAgIHRoaXMuZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy50ZXh0dXJlcy5jbGVhcigpO1xuICAgICAgdGhpcy5nbC5kZWxldGVQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG4gICAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xuICAgICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCBudWxsKTtcbiAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBudWxsKTtcbiAgICAgIHRoaXMuZ2wuYmluZFJlbmRlcmJ1ZmZlcih0aGlzLmdsLlJFTkRFUkJVRkZFUiwgbnVsbCk7XG4gICAgICB0aGlzLmdsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLmdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICAgIHRoaXMuZ2wuZ2V0RXJyb3IoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG51bGw7XG4gICAgfVxuICAgIHZpc3VhbFZpZXdwb3J0Py5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMuaGFuZGxlVmlzdWFsVmlld3BvcnRDaGFuZ2UpO1xuICAgIHRoaXMudW5pZm9ybUxvY2F0aW9ucyA9IHt9O1xuICAgIHRoaXMucGFyZW50RWxlbWVudC5wYXBlclNoYWRlck1vdW50ID0gdm9pZCAwO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU2hhZGVyKGdsLCB0eXBlLCBzb3VyY2UpIHtcbiAgY29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xuICBpZiAoIXNoYWRlcikgcmV0dXJuIG51bGw7XG4gIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNvdXJjZSk7XG4gIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcbiAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiQW4gZXJyb3Igb2NjdXJyZWQgY29tcGlsaW5nIHRoZSBzaGFkZXJzOiBcIiArIGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKSk7XG4gICAgZ2wuZGVsZXRlU2hhZGVyKHNoYWRlcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHNoYWRlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0oZ2wsIHZlcnRleFNoYWRlclNvdXJjZTIsIGZyYWdtZW50U2hhZGVyU291cmNlKSB7XG4gIGNvbnN0IGZvcm1hdCA9IGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLk1FRElVTV9GTE9BVCk7XG4gIGNvbnN0IHByZWNpc2lvbiA9IGZvcm1hdCA/IGZvcm1hdC5wcmVjaXNpb24gOiBudWxsO1xuICBpZiAocHJlY2lzaW9uICYmIHByZWNpc2lvbiA8IDIzKSB7XG4gICAgdmVydGV4U2hhZGVyU291cmNlMiA9IHZlcnRleFNoYWRlclNvdXJjZTIucmVwbGFjZSgvcHJlY2lzaW9uXFxzKyhsb3dwfG1lZGl1bXApXFxzK2Zsb2F0Oy9nLCBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcIik7XG4gICAgZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBmcmFnbWVudFNoYWRlclNvdXJjZS5yZXBsYWNlKC9wcmVjaXNpb25cXHMrKGxvd3B8bWVkaXVtcClcXHMrZmxvYXQvZywgXCJwcmVjaXNpb24gaGlnaHAgZmxvYXRcIikucmVwbGFjZSgvXFxiKHVuaWZvcm18dmFyeWluZ3xhdHRyaWJ1dGUpXFxzKyhsb3dwfG1lZGl1bXApXFxzKyhcXHcrKS9nLCBcIiQxIGhpZ2hwICQzXCIpO1xuICB9XG4gIGNvbnN0IHZlcnRleFNoYWRlciA9IGNyZWF0ZVNoYWRlcihnbCwgZ2wuVkVSVEVYX1NIQURFUiwgdmVydGV4U2hhZGVyU291cmNlMik7XG4gIGNvbnN0IGZyYWdtZW50U2hhZGVyID0gY3JlYXRlU2hhZGVyKGdsLCBnbC5GUkFHTUVOVF9TSEFERVIsIGZyYWdtZW50U2hhZGVyU291cmNlKTtcbiAgaWYgKCF2ZXJ0ZXhTaGFkZXIgfHwgIWZyYWdtZW50U2hhZGVyKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgaWYgKCFwcm9ncmFtKSByZXR1cm4gbnVsbDtcbiAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XG4gIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XG4gIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlVuYWJsZSB0byBpbml0aWFsaXplIHRoZSBzaGFkZXIgcHJvZ3JhbTogXCIgKyBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XG4gICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICBnbC5kZWxldGVTaGFkZXIodmVydGV4U2hhZGVyKTtcbiAgICBnbC5kZWxldGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdsLmRldGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xuICBnbC5kZXRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xuICBnbC5kZWxldGVTaGFkZXIodmVydGV4U2hhZGVyKTtcbiAgZ2wuZGVsZXRlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcbiAgcmV0dXJuIHByb2dyYW07XG59XG5jb25zdCBkZWZhdWx0U3R5bGUgPSBgQGxheWVyIHBhcGVyLXNoYWRlcnMge1xuICA6d2hlcmUoW2RhdGEtcGFwZXItc2hhZGVyXSkge1xuICAgIGlzb2xhdGlvbjogaXNvbGF0ZTtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG5cbiAgICAmIGNhbnZhcyB7XG4gICAgICBjb250YWluOiBzdHJpY3Q7XG4gICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIGluc2V0OiAwO1xuICAgICAgei1pbmRleDogLTE7XG4gICAgICB3aWR0aDogMTAwJTtcbiAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgIGJvcmRlci1yYWRpdXM6IGluaGVyaXQ7XG4gICAgICBjb3JuZXItc2hhcGU6IGluaGVyaXQ7XG4gICAgfVxuICB9XG59YDtcbmZ1bmN0aW9uIGlzUGFwZXJTaGFkZXJFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIFwicGFwZXJTaGFkZXJNb3VudFwiIGluIGVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc1NhZmFyaSgpIHtcbiAgY29uc3QgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiB1YS5pbmNsdWRlcyhcInNhZmFyaVwiKSAmJiAhdWEuaW5jbHVkZXMoXCJjaHJvbWVcIikgJiYgIXVhLmluY2x1ZGVzKFwiYW5kcm9pZFwiKTtcbn1cbmV4cG9ydCB7XG4gIFNoYWRlck1vdW50LFxuICBpc1BhcGVyU2hhZGVyRWxlbWVudFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYWRlci1tb3VudC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/shader-mount.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/shader-sizing.js":
/*!******************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/shader-sizing.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShaderFitOptions: () => (/* binding */ ShaderFitOptions),\n/* harmony export */   defaultObjectSizing: () => (/* binding */ defaultObjectSizing),\n/* harmony export */   defaultPatternSizing: () => (/* binding */ defaultPatternSizing),\n/* harmony export */   drawSizingHelpers: () => (/* binding */ drawSizingHelpers),\n/* harmony export */   sizingDebugVariablesDeclaration: () => (/* binding */ sizingDebugVariablesDeclaration),\n/* harmony export */   sizingUV: () => (/* binding */ sizingUV),\n/* harmony export */   sizingUniformsDeclaration: () => (/* binding */ sizingUniformsDeclaration),\n/* harmony export */   sizingVariablesDeclaration: () => (/* binding */ sizingVariablesDeclaration)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nconst sizingVariablesDeclaration = `\nin vec2 v_objectUV;\nin vec2 v_responsiveUV;\nin vec2 v_responsiveBoxGivenSize;\nin vec2 v_patternUV;\nin vec2 v_imageUV;`;\nconst sizingDebugVariablesDeclaration = `\nin vec2 v_objectBoxSize;\nin vec2 v_objectHelperBox;\nin vec2 v_responsiveBoxSize;\nin vec2 v_responsiveHelperBox;\nin vec2 v_patternBoxSize;\nin vec2 v_patternHelperBox;`;\nconst sizingUniformsDeclaration = `\nuniform float u_originX;\nuniform float u_originY;\nuniform float u_worldWidth;\nuniform float u_worldHeight;\nuniform float u_fit;\n\nuniform float u_scale;\nuniform float u_rotation;\nuniform float u_offsetX;\nuniform float u_offsetY;`;\nconst sizingUV = `\n\n  vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n  #ifdef USE_PIXELIZATION\n    float pxSize = u_pxSize * u_pixelRatio;\n    vec2 pxSizeUv = gl_FragCoord.xy;\n    pxSizeUv -= .5 * u_resolution;\n    pxSizeUv /= pxSize;\n    uv = floor(pxSizeUv) * pxSize / u_resolution.xy;    \n    uv += .5;\n  #endif\n  uv -= .5;\n\n  \n  // ===================================================\n  // sizing params shared between objects and patterns\n  \n  vec2 boxOrigin = vec2(.5 - u_originX, u_originY - .5);\n  vec2 givenBoxSize = vec2(u_worldWidth, u_worldHeight);\n  givenBoxSize = max(givenBoxSize, vec2(1.)) * u_pixelRatio;\n  float r = u_rotation * 3.14159265358979323846 / 180.;\n  mat2 graphicRotation = mat2(cos(r), sin(r), -sin(r), cos(r));\n  vec2 graphicOffset = vec2(-u_offsetX, u_offsetY);\n\n  \n  // ===================================================\n  // Sizing api for objects (graphics with fixed ratio)\n\n  #ifdef USE_OBJECT_SIZING\n    float fixedRatio = 1.;\n    vec2 fixedRatioBoxGivenSize = vec2(\n      (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n      (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n    );\n    vec2 objectBoxSize = vec2(0.);\n    // fit = none\n    objectBoxSize.x = fixedRatio * min(fixedRatioBoxGivenSize.x / fixedRatio, fixedRatioBoxGivenSize.y);\n    if (u_fit == 1.) { // fit = contain\n      objectBoxSize.x = fixedRatio * min(u_resolution.x / fixedRatio, u_resolution.y);\n    } else if (u_fit == 2.) {  // fit = cover\n      objectBoxSize.x = fixedRatio * max(u_resolution.x / fixedRatio, u_resolution.y);\n    }\n    objectBoxSize.y = objectBoxSize.x / fixedRatio;\n    vec2 objectWorldScale = u_resolution.xy / objectBoxSize;\n  \n    #ifdef ADD_HELPERS\n      vec2 objectHelperBox = gl_FragCoord.xy / u_resolution.xy;\n      objectHelperBox -= .5;\n      objectHelperBox *= objectWorldScale;\n      objectHelperBox += boxOrigin * (objectWorldScale - 1.);  \n    #endif\n  \n    vec2 objectUV = uv;\n    objectUV *= objectWorldScale;\n    objectUV += boxOrigin * (objectWorldScale - 1.);\n    objectUV += vec2(-u_offsetX, u_offsetY);\n    objectUV /= u_scale;\n    objectUV = graphicRotation * objectUV;\n  #endif\n  \n  // ===================================================\n \n  // ===================================================\n  // Sizing api for patterns (graphics respecting u_worldWidth / u_worldHeight ratio)\n  \n  #ifdef USE_PATTERN_SIZING\n    float patternBoxRatio = givenBoxSize.x / givenBoxSize.y;\n    vec2 patternBoxGivenSize = vec2(\n      (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n      (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n    );\n    vec2 patternBoxSize = vec2(0.);\n    // fit = none\n    patternBoxSize.x = patternBoxRatio * min(patternBoxGivenSize.x / patternBoxRatio, patternBoxGivenSize.y);\n    float patternWorldNoFitBoxWidth = patternBoxSize.x;\n    if (u_fit == 1.) {  // fit = contain\n      patternBoxSize.x = patternBoxRatio * min(u_resolution.x / patternBoxRatio, u_resolution.y);\n    } else if (u_fit == 2.) {  // fit = cover\n      patternBoxSize.x = patternBoxRatio * max(u_resolution.x / patternBoxRatio, u_resolution.y);\n    }\n    patternBoxSize.y = patternBoxSize.x / patternBoxRatio;\n    vec2 patternWorldScale = u_resolution.xy / patternBoxSize;\n  \n    #ifdef ADD_HELPERS  \n      vec2 patternHelperBox = gl_FragCoord.xy / u_resolution.xy;\n      patternHelperBox -= .5;\n      patternHelperBox *= patternWorldScale;\n      patternHelperBox += boxOrigin * (patternWorldScale - 1.);  \n    #endif\n  \n    vec2 patternUV = uv;\n    patternUV += vec2(-u_offsetX, u_offsetY) / patternWorldScale;\n    patternUV += boxOrigin;\n    patternUV -= boxOrigin / patternWorldScale;\n    patternUV *= u_resolution.xy;\n    patternUV /= u_pixelRatio;\n    if (u_fit > 0.) {\n      patternUV *= (patternWorldNoFitBoxWidth / patternBoxSize.x);\n    }\n    patternUV /= u_scale;\n    patternUV = graphicRotation * patternUV;\n    patternUV += boxOrigin / patternWorldScale;\n    patternUV -= boxOrigin;\n    patternUV += .5;\n  #endif\n    \n  // ===================================================\n \n  // ===================================================\n  // Sizing api for image filters\n  \n  #ifdef USE_IMAGE_SIZING\n\n    vec2 imageBoxSize;\n    if (u_fit == 1.) { // contain\n      imageBoxSize.x = min(u_resolution.x / u_imageAspectRatio, u_resolution.y) * u_imageAspectRatio;\n    } else if (u_fit == 2.) { // cover\n      imageBoxSize.x = max(u_resolution.x / u_imageAspectRatio, u_resolution.y) * u_imageAspectRatio;\n    } else {\n      imageBoxSize.x = min(10.0, 10.0 / u_imageAspectRatio * u_imageAspectRatio);\n    }\n    imageBoxSize.y = imageBoxSize.x / u_imageAspectRatio;\n    vec2 imageBoxScale = u_resolution.xy / imageBoxSize;\n\n    #ifdef ADD_HELPERS\n      vec2 imageHelperBox = uv;\n      imageHelperBox *= imageBoxScale;\n      imageHelperBox += boxOrigin * (imageBoxScale - 1.);\n    #endif\n\n    vec2 imageUV = uv;\n    imageUV *= imageBoxScale;\n    imageUV += boxOrigin * (imageBoxScale - 1.);\n    imageUV += graphicOffset;\n    imageUV /= u_scale;\n    imageUV.x *= u_imageAspectRatio;\n    imageUV = graphicRotation * imageUV;\n    imageUV.x /= u_imageAspectRatio;\n    \n    imageUV += .5;\n    imageUV.y = 1. - imageUV.y;\n  #endif\n`;\nconst drawSizingHelpers = `\n  vec2 worldBoxDist = abs(helperBox);\n  float boxStroke = (step(max(worldBoxDist.x, worldBoxDist.y), .5) - step(max(worldBoxDist.x, worldBoxDist.y), .495));\n  color.rgb = mix(color.rgb, vec3(1., 0., 0.), boxStroke);\n  opacity += boxStroke;\n\n  vec2 boxOriginCopy = vec2(.5 - u_originX, u_originY - .5);\n  vec2 boxOriginDist = helperBox + boxOriginCopy;\n  boxOriginDist.x *= (boxSize.x / boxSize.y);\n  float boxOriginPoint = 1. - smoothstep(0., .05, length(boxOriginDist));\n  \n  vec2 graphicOriginPointDist = helperBox + vec2(-u_offsetX, u_offsetY);\n  graphicOriginPointDist.x *= (boxSize.x / boxSize.y);\n  float graphicOriginPoint = 1. - smoothstep(0., .05, length(graphicOriginPointDist));\n  \n  color.rgb = mix(color.rgb, vec3(0., 1., 0.), boxOriginPoint);\n  opacity += boxOriginPoint;\n  color.rgb = mix(color.rgb, vec3(0., 0., 1.), graphicOriginPoint);\n  opacity += graphicOriginPoint;\n`;\nconst defaultObjectSizing = {\n  fit: \"contain\",\n  scale: 1,\n  rotation: 0,\n  offsetX: 0,\n  offsetY: 0,\n  originX: 0.5,\n  originY: 0.5,\n  worldWidth: 0,\n  worldHeight: 0\n};\nconst defaultPatternSizing = {\n  fit: \"none\",\n  scale: 1,\n  rotation: 0,\n  offsetX: 0,\n  offsetY: 0,\n  originX: 0.5,\n  originY: 0.5,\n  worldWidth: 0,\n  worldHeight: 0\n};\nconst ShaderFitOptions = {\n  none: 0,\n  contain: 1,\n  cover: 2\n};\n\n//# sourceMappingURL=shader-sizing.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLXNpemluZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLE1BQU0seUJBQXlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxNQUFNLHlCQUF5QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLE1BQU0sd0JBQXdCO0FBQzlCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFVRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvaW1yYW5tb2hhbW1lZC9kZXNpZ24td2l0aC1jbGF1ZGUvd2ViL25vZGVfbW9kdWxlcy9AcGFwZXItZGVzaWduL3NoYWRlcnMvZGlzdC9zaGFkZXItc2l6aW5nLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiAgICAgICAgICAgICAgICAgICAgUGFwZXIgU2hhZGVycyAgICAgICAgICAgICAgICAgICAgKlxuICogICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3BhcGVyLWRlc2lnbi9zaGFkZXJzICAgICAgICpcbiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuXG5jb25zdCBzaXppbmdWYXJpYWJsZXNEZWNsYXJhdGlvbiA9IGBcbmluIHZlYzIgdl9vYmplY3RVVjtcbmluIHZlYzIgdl9yZXNwb25zaXZlVVY7XG5pbiB2ZWMyIHZfcmVzcG9uc2l2ZUJveEdpdmVuU2l6ZTtcbmluIHZlYzIgdl9wYXR0ZXJuVVY7XG5pbiB2ZWMyIHZfaW1hZ2VVVjtgO1xuY29uc3Qgc2l6aW5nRGVidWdWYXJpYWJsZXNEZWNsYXJhdGlvbiA9IGBcbmluIHZlYzIgdl9vYmplY3RCb3hTaXplO1xuaW4gdmVjMiB2X29iamVjdEhlbHBlckJveDtcbmluIHZlYzIgdl9yZXNwb25zaXZlQm94U2l6ZTtcbmluIHZlYzIgdl9yZXNwb25zaXZlSGVscGVyQm94O1xuaW4gdmVjMiB2X3BhdHRlcm5Cb3hTaXplO1xuaW4gdmVjMiB2X3BhdHRlcm5IZWxwZXJCb3g7YDtcbmNvbnN0IHNpemluZ1VuaWZvcm1zRGVjbGFyYXRpb24gPSBgXG51bmlmb3JtIGZsb2F0IHVfb3JpZ2luWDtcbnVuaWZvcm0gZmxvYXQgdV9vcmlnaW5ZO1xudW5pZm9ybSBmbG9hdCB1X3dvcmxkV2lkdGg7XG51bmlmb3JtIGZsb2F0IHVfd29ybGRIZWlnaHQ7XG51bmlmb3JtIGZsb2F0IHVfZml0O1xuXG51bmlmb3JtIGZsb2F0IHVfc2NhbGU7XG51bmlmb3JtIGZsb2F0IHVfcm90YXRpb247XG51bmlmb3JtIGZsb2F0IHVfb2Zmc2V0WDtcbnVuaWZvcm0gZmxvYXQgdV9vZmZzZXRZO2A7XG5jb25zdCBzaXppbmdVViA9IGBcblxuICB2ZWMyIHV2ID0gZ2xfRnJhZ0Nvb3JkLnh5IC8gdV9yZXNvbHV0aW9uLnh5O1xuICAjaWZkZWYgVVNFX1BJWEVMSVpBVElPTlxuICAgIGZsb2F0IHB4U2l6ZSA9IHVfcHhTaXplICogdV9waXhlbFJhdGlvO1xuICAgIHZlYzIgcHhTaXplVXYgPSBnbF9GcmFnQ29vcmQueHk7XG4gICAgcHhTaXplVXYgLT0gLjUgKiB1X3Jlc29sdXRpb247XG4gICAgcHhTaXplVXYgLz0gcHhTaXplO1xuICAgIHV2ID0gZmxvb3IocHhTaXplVXYpICogcHhTaXplIC8gdV9yZXNvbHV0aW9uLnh5OyAgICBcbiAgICB1diArPSAuNTtcbiAgI2VuZGlmXG4gIHV2IC09IC41O1xuXG4gIFxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gc2l6aW5nIHBhcmFtcyBzaGFyZWQgYmV0d2VlbiBvYmplY3RzIGFuZCBwYXR0ZXJuc1xuICBcbiAgdmVjMiBib3hPcmlnaW4gPSB2ZWMyKC41IC0gdV9vcmlnaW5YLCB1X29yaWdpblkgLSAuNSk7XG4gIHZlYzIgZ2l2ZW5Cb3hTaXplID0gdmVjMih1X3dvcmxkV2lkdGgsIHVfd29ybGRIZWlnaHQpO1xuICBnaXZlbkJveFNpemUgPSBtYXgoZ2l2ZW5Cb3hTaXplLCB2ZWMyKDEuKSkgKiB1X3BpeGVsUmF0aW87XG4gIGZsb2F0IHIgPSB1X3JvdGF0aW9uICogMy4xNDE1OTI2NTM1ODk3OTMyMzg0NiAvIDE4MC47XG4gIG1hdDIgZ3JhcGhpY1JvdGF0aW9uID0gbWF0Mihjb3MociksIHNpbihyKSwgLXNpbihyKSwgY29zKHIpKTtcbiAgdmVjMiBncmFwaGljT2Zmc2V0ID0gdmVjMigtdV9vZmZzZXRYLCB1X29mZnNldFkpO1xuXG4gIFxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gU2l6aW5nIGFwaSBmb3Igb2JqZWN0cyAoZ3JhcGhpY3Mgd2l0aCBmaXhlZCByYXRpbylcblxuICAjaWZkZWYgVVNFX09CSkVDVF9TSVpJTkdcbiAgICBmbG9hdCBmaXhlZFJhdGlvID0gMS47XG4gICAgdmVjMiBmaXhlZFJhdGlvQm94R2l2ZW5TaXplID0gdmVjMihcbiAgICAgICh1X3dvcmxkV2lkdGggPT0gMC4pID8gdV9yZXNvbHV0aW9uLnggOiBnaXZlbkJveFNpemUueCxcbiAgICAgICh1X3dvcmxkSGVpZ2h0ID09IDAuKSA/IHVfcmVzb2x1dGlvbi55IDogZ2l2ZW5Cb3hTaXplLnlcbiAgICApO1xuICAgIHZlYzIgb2JqZWN0Qm94U2l6ZSA9IHZlYzIoMC4pO1xuICAgIC8vIGZpdCA9IG5vbmVcbiAgICBvYmplY3RCb3hTaXplLnggPSBmaXhlZFJhdGlvICogbWluKGZpeGVkUmF0aW9Cb3hHaXZlblNpemUueCAvIGZpeGVkUmF0aW8sIGZpeGVkUmF0aW9Cb3hHaXZlblNpemUueSk7XG4gICAgaWYgKHVfZml0ID09IDEuKSB7IC8vIGZpdCA9IGNvbnRhaW5cbiAgICAgIG9iamVjdEJveFNpemUueCA9IGZpeGVkUmF0aW8gKiBtaW4odV9yZXNvbHV0aW9uLnggLyBmaXhlZFJhdGlvLCB1X3Jlc29sdXRpb24ueSk7XG4gICAgfSBlbHNlIGlmICh1X2ZpdCA9PSAyLikgeyAgLy8gZml0ID0gY292ZXJcbiAgICAgIG9iamVjdEJveFNpemUueCA9IGZpeGVkUmF0aW8gKiBtYXgodV9yZXNvbHV0aW9uLnggLyBmaXhlZFJhdGlvLCB1X3Jlc29sdXRpb24ueSk7XG4gICAgfVxuICAgIG9iamVjdEJveFNpemUueSA9IG9iamVjdEJveFNpemUueCAvIGZpeGVkUmF0aW87XG4gICAgdmVjMiBvYmplY3RXb3JsZFNjYWxlID0gdV9yZXNvbHV0aW9uLnh5IC8gb2JqZWN0Qm94U2l6ZTtcbiAgXG4gICAgI2lmZGVmIEFERF9IRUxQRVJTXG4gICAgICB2ZWMyIG9iamVjdEhlbHBlckJveCA9IGdsX0ZyYWdDb29yZC54eSAvIHVfcmVzb2x1dGlvbi54eTtcbiAgICAgIG9iamVjdEhlbHBlckJveCAtPSAuNTtcbiAgICAgIG9iamVjdEhlbHBlckJveCAqPSBvYmplY3RXb3JsZFNjYWxlO1xuICAgICAgb2JqZWN0SGVscGVyQm94ICs9IGJveE9yaWdpbiAqIChvYmplY3RXb3JsZFNjYWxlIC0gMS4pOyAgXG4gICAgI2VuZGlmXG4gIFxuICAgIHZlYzIgb2JqZWN0VVYgPSB1djtcbiAgICBvYmplY3RVViAqPSBvYmplY3RXb3JsZFNjYWxlO1xuICAgIG9iamVjdFVWICs9IGJveE9yaWdpbiAqIChvYmplY3RXb3JsZFNjYWxlIC0gMS4pO1xuICAgIG9iamVjdFVWICs9IHZlYzIoLXVfb2Zmc2V0WCwgdV9vZmZzZXRZKTtcbiAgICBvYmplY3RVViAvPSB1X3NjYWxlO1xuICAgIG9iamVjdFVWID0gZ3JhcGhpY1JvdGF0aW9uICogb2JqZWN0VVY7XG4gICNlbmRpZlxuICBcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBTaXppbmcgYXBpIGZvciBwYXR0ZXJucyAoZ3JhcGhpY3MgcmVzcGVjdGluZyB1X3dvcmxkV2lkdGggLyB1X3dvcmxkSGVpZ2h0IHJhdGlvKVxuICBcbiAgI2lmZGVmIFVTRV9QQVRURVJOX1NJWklOR1xuICAgIGZsb2F0IHBhdHRlcm5Cb3hSYXRpbyA9IGdpdmVuQm94U2l6ZS54IC8gZ2l2ZW5Cb3hTaXplLnk7XG4gICAgdmVjMiBwYXR0ZXJuQm94R2l2ZW5TaXplID0gdmVjMihcbiAgICAgICh1X3dvcmxkV2lkdGggPT0gMC4pID8gdV9yZXNvbHV0aW9uLnggOiBnaXZlbkJveFNpemUueCxcbiAgICAgICh1X3dvcmxkSGVpZ2h0ID09IDAuKSA/IHVfcmVzb2x1dGlvbi55IDogZ2l2ZW5Cb3hTaXplLnlcbiAgICApO1xuICAgIHZlYzIgcGF0dGVybkJveFNpemUgPSB2ZWMyKDAuKTtcbiAgICAvLyBmaXQgPSBub25lXG4gICAgcGF0dGVybkJveFNpemUueCA9IHBhdHRlcm5Cb3hSYXRpbyAqIG1pbihwYXR0ZXJuQm94R2l2ZW5TaXplLnggLyBwYXR0ZXJuQm94UmF0aW8sIHBhdHRlcm5Cb3hHaXZlblNpemUueSk7XG4gICAgZmxvYXQgcGF0dGVybldvcmxkTm9GaXRCb3hXaWR0aCA9IHBhdHRlcm5Cb3hTaXplLng7XG4gICAgaWYgKHVfZml0ID09IDEuKSB7ICAvLyBmaXQgPSBjb250YWluXG4gICAgICBwYXR0ZXJuQm94U2l6ZS54ID0gcGF0dGVybkJveFJhdGlvICogbWluKHVfcmVzb2x1dGlvbi54IC8gcGF0dGVybkJveFJhdGlvLCB1X3Jlc29sdXRpb24ueSk7XG4gICAgfSBlbHNlIGlmICh1X2ZpdCA9PSAyLikgeyAgLy8gZml0ID0gY292ZXJcbiAgICAgIHBhdHRlcm5Cb3hTaXplLnggPSBwYXR0ZXJuQm94UmF0aW8gKiBtYXgodV9yZXNvbHV0aW9uLnggLyBwYXR0ZXJuQm94UmF0aW8sIHVfcmVzb2x1dGlvbi55KTtcbiAgICB9XG4gICAgcGF0dGVybkJveFNpemUueSA9IHBhdHRlcm5Cb3hTaXplLnggLyBwYXR0ZXJuQm94UmF0aW87XG4gICAgdmVjMiBwYXR0ZXJuV29ybGRTY2FsZSA9IHVfcmVzb2x1dGlvbi54eSAvIHBhdHRlcm5Cb3hTaXplO1xuICBcbiAgICAjaWZkZWYgQUREX0hFTFBFUlMgIFxuICAgICAgdmVjMiBwYXR0ZXJuSGVscGVyQm94ID0gZ2xfRnJhZ0Nvb3JkLnh5IC8gdV9yZXNvbHV0aW9uLnh5O1xuICAgICAgcGF0dGVybkhlbHBlckJveCAtPSAuNTtcbiAgICAgIHBhdHRlcm5IZWxwZXJCb3ggKj0gcGF0dGVybldvcmxkU2NhbGU7XG4gICAgICBwYXR0ZXJuSGVscGVyQm94ICs9IGJveE9yaWdpbiAqIChwYXR0ZXJuV29ybGRTY2FsZSAtIDEuKTsgIFxuICAgICNlbmRpZlxuICBcbiAgICB2ZWMyIHBhdHRlcm5VViA9IHV2O1xuICAgIHBhdHRlcm5VViArPSB2ZWMyKC11X29mZnNldFgsIHVfb2Zmc2V0WSkgLyBwYXR0ZXJuV29ybGRTY2FsZTtcbiAgICBwYXR0ZXJuVVYgKz0gYm94T3JpZ2luO1xuICAgIHBhdHRlcm5VViAtPSBib3hPcmlnaW4gLyBwYXR0ZXJuV29ybGRTY2FsZTtcbiAgICBwYXR0ZXJuVVYgKj0gdV9yZXNvbHV0aW9uLnh5O1xuICAgIHBhdHRlcm5VViAvPSB1X3BpeGVsUmF0aW87XG4gICAgaWYgKHVfZml0ID4gMC4pIHtcbiAgICAgIHBhdHRlcm5VViAqPSAocGF0dGVybldvcmxkTm9GaXRCb3hXaWR0aCAvIHBhdHRlcm5Cb3hTaXplLngpO1xuICAgIH1cbiAgICBwYXR0ZXJuVVYgLz0gdV9zY2FsZTtcbiAgICBwYXR0ZXJuVVYgPSBncmFwaGljUm90YXRpb24gKiBwYXR0ZXJuVVY7XG4gICAgcGF0dGVyblVWICs9IGJveE9yaWdpbiAvIHBhdHRlcm5Xb3JsZFNjYWxlO1xuICAgIHBhdHRlcm5VViAtPSBib3hPcmlnaW47XG4gICAgcGF0dGVyblVWICs9IC41O1xuICAjZW5kaWZcbiAgICBcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBTaXppbmcgYXBpIGZvciBpbWFnZSBmaWx0ZXJzXG4gIFxuICAjaWZkZWYgVVNFX0lNQUdFX1NJWklOR1xuXG4gICAgdmVjMiBpbWFnZUJveFNpemU7XG4gICAgaWYgKHVfZml0ID09IDEuKSB7IC8vIGNvbnRhaW5cbiAgICAgIGltYWdlQm94U2l6ZS54ID0gbWluKHVfcmVzb2x1dGlvbi54IC8gdV9pbWFnZUFzcGVjdFJhdGlvLCB1X3Jlc29sdXRpb24ueSkgKiB1X2ltYWdlQXNwZWN0UmF0aW87XG4gICAgfSBlbHNlIGlmICh1X2ZpdCA9PSAyLikgeyAvLyBjb3ZlclxuICAgICAgaW1hZ2VCb3hTaXplLnggPSBtYXgodV9yZXNvbHV0aW9uLnggLyB1X2ltYWdlQXNwZWN0UmF0aW8sIHVfcmVzb2x1dGlvbi55KSAqIHVfaW1hZ2VBc3BlY3RSYXRpbztcbiAgICB9IGVsc2Uge1xuICAgICAgaW1hZ2VCb3hTaXplLnggPSBtaW4oMTAuMCwgMTAuMCAvIHVfaW1hZ2VBc3BlY3RSYXRpbyAqIHVfaW1hZ2VBc3BlY3RSYXRpbyk7XG4gICAgfVxuICAgIGltYWdlQm94U2l6ZS55ID0gaW1hZ2VCb3hTaXplLnggLyB1X2ltYWdlQXNwZWN0UmF0aW87XG4gICAgdmVjMiBpbWFnZUJveFNjYWxlID0gdV9yZXNvbHV0aW9uLnh5IC8gaW1hZ2VCb3hTaXplO1xuXG4gICAgI2lmZGVmIEFERF9IRUxQRVJTXG4gICAgICB2ZWMyIGltYWdlSGVscGVyQm94ID0gdXY7XG4gICAgICBpbWFnZUhlbHBlckJveCAqPSBpbWFnZUJveFNjYWxlO1xuICAgICAgaW1hZ2VIZWxwZXJCb3ggKz0gYm94T3JpZ2luICogKGltYWdlQm94U2NhbGUgLSAxLik7XG4gICAgI2VuZGlmXG5cbiAgICB2ZWMyIGltYWdlVVYgPSB1djtcbiAgICBpbWFnZVVWICo9IGltYWdlQm94U2NhbGU7XG4gICAgaW1hZ2VVViArPSBib3hPcmlnaW4gKiAoaW1hZ2VCb3hTY2FsZSAtIDEuKTtcbiAgICBpbWFnZVVWICs9IGdyYXBoaWNPZmZzZXQ7XG4gICAgaW1hZ2VVViAvPSB1X3NjYWxlO1xuICAgIGltYWdlVVYueCAqPSB1X2ltYWdlQXNwZWN0UmF0aW87XG4gICAgaW1hZ2VVViA9IGdyYXBoaWNSb3RhdGlvbiAqIGltYWdlVVY7XG4gICAgaW1hZ2VVVi54IC89IHVfaW1hZ2VBc3BlY3RSYXRpbztcbiAgICBcbiAgICBpbWFnZVVWICs9IC41O1xuICAgIGltYWdlVVYueSA9IDEuIC0gaW1hZ2VVVi55O1xuICAjZW5kaWZcbmA7XG5jb25zdCBkcmF3U2l6aW5nSGVscGVycyA9IGBcbiAgdmVjMiB3b3JsZEJveERpc3QgPSBhYnMoaGVscGVyQm94KTtcbiAgZmxvYXQgYm94U3Ryb2tlID0gKHN0ZXAobWF4KHdvcmxkQm94RGlzdC54LCB3b3JsZEJveERpc3QueSksIC41KSAtIHN0ZXAobWF4KHdvcmxkQm94RGlzdC54LCB3b3JsZEJveERpc3QueSksIC40OTUpKTtcbiAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgdmVjMygxLiwgMC4sIDAuKSwgYm94U3Ryb2tlKTtcbiAgb3BhY2l0eSArPSBib3hTdHJva2U7XG5cbiAgdmVjMiBib3hPcmlnaW5Db3B5ID0gdmVjMiguNSAtIHVfb3JpZ2luWCwgdV9vcmlnaW5ZIC0gLjUpO1xuICB2ZWMyIGJveE9yaWdpbkRpc3QgPSBoZWxwZXJCb3ggKyBib3hPcmlnaW5Db3B5O1xuICBib3hPcmlnaW5EaXN0LnggKj0gKGJveFNpemUueCAvIGJveFNpemUueSk7XG4gIGZsb2F0IGJveE9yaWdpblBvaW50ID0gMS4gLSBzbW9vdGhzdGVwKDAuLCAuMDUsIGxlbmd0aChib3hPcmlnaW5EaXN0KSk7XG4gIFxuICB2ZWMyIGdyYXBoaWNPcmlnaW5Qb2ludERpc3QgPSBoZWxwZXJCb3ggKyB2ZWMyKC11X29mZnNldFgsIHVfb2Zmc2V0WSk7XG4gIGdyYXBoaWNPcmlnaW5Qb2ludERpc3QueCAqPSAoYm94U2l6ZS54IC8gYm94U2l6ZS55KTtcbiAgZmxvYXQgZ3JhcGhpY09yaWdpblBvaW50ID0gMS4gLSBzbW9vdGhzdGVwKDAuLCAuMDUsIGxlbmd0aChncmFwaGljT3JpZ2luUG9pbnREaXN0KSk7XG4gIFxuICBjb2xvci5yZ2IgPSBtaXgoY29sb3IucmdiLCB2ZWMzKDAuLCAxLiwgMC4pLCBib3hPcmlnaW5Qb2ludCk7XG4gIG9wYWNpdHkgKz0gYm94T3JpZ2luUG9pbnQ7XG4gIGNvbG9yLnJnYiA9IG1peChjb2xvci5yZ2IsIHZlYzMoMC4sIDAuLCAxLiksIGdyYXBoaWNPcmlnaW5Qb2ludCk7XG4gIG9wYWNpdHkgKz0gZ3JhcGhpY09yaWdpblBvaW50O1xuYDtcbmNvbnN0IGRlZmF1bHRPYmplY3RTaXppbmcgPSB7XG4gIGZpdDogXCJjb250YWluXCIsXG4gIHNjYWxlOiAxLFxuICByb3RhdGlvbjogMCxcbiAgb2Zmc2V0WDogMCxcbiAgb2Zmc2V0WTogMCxcbiAgb3JpZ2luWDogMC41LFxuICBvcmlnaW5ZOiAwLjUsXG4gIHdvcmxkV2lkdGg6IDAsXG4gIHdvcmxkSGVpZ2h0OiAwXG59O1xuY29uc3QgZGVmYXVsdFBhdHRlcm5TaXppbmcgPSB7XG4gIGZpdDogXCJub25lXCIsXG4gIHNjYWxlOiAxLFxuICByb3RhdGlvbjogMCxcbiAgb2Zmc2V0WDogMCxcbiAgb2Zmc2V0WTogMCxcbiAgb3JpZ2luWDogMC41LFxuICBvcmlnaW5ZOiAwLjUsXG4gIHdvcmxkV2lkdGg6IDAsXG4gIHdvcmxkSGVpZ2h0OiAwXG59O1xuY29uc3QgU2hhZGVyRml0T3B0aW9ucyA9IHtcbiAgbm9uZTogMCxcbiAgY29udGFpbjogMSxcbiAgY292ZXI6IDJcbn07XG5leHBvcnQge1xuICBTaGFkZXJGaXRPcHRpb25zLFxuICBkZWZhdWx0T2JqZWN0U2l6aW5nLFxuICBkZWZhdWx0UGF0dGVyblNpemluZyxcbiAgZHJhd1NpemluZ0hlbHBlcnMsXG4gIHNpemluZ0RlYnVnVmFyaWFibGVzRGVjbGFyYXRpb24sXG4gIHNpemluZ1VWLFxuICBzaXppbmdVbmlmb3Jtc0RlY2xhcmF0aW9uLFxuICBzaXppbmdWYXJpYWJsZXNEZWNsYXJhdGlvblxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYWRlci1zaXppbmcuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/shader-sizing.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/shader-utils.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/shader-utils.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   colorBandingFix: () => (/* binding */ colorBandingFix),\n/* harmony export */   declarePI: () => (/* binding */ declarePI),\n/* harmony export */   fiberNoise: () => (/* binding */ fiberNoise),\n/* harmony export */   proceduralHash11: () => (/* binding */ proceduralHash11),\n/* harmony export */   proceduralHash21: () => (/* binding */ proceduralHash21),\n/* harmony export */   proceduralHash22: () => (/* binding */ proceduralHash22),\n/* harmony export */   rotation2: () => (/* binding */ rotation2),\n/* harmony export */   simplexNoise: () => (/* binding */ simplexNoise),\n/* harmony export */   textureRandomizerGB: () => (/* binding */ textureRandomizerGB),\n/* harmony export */   textureRandomizerR: () => (/* binding */ textureRandomizerR)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nconst declarePI = `\n#define TWO_PI 6.28318530718\n#define PI 3.14159265358979323846\n`;\nconst rotation2 = `\nvec2 rotate(vec2 uv, float th) {\n  return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n}\n`;\nconst proceduralHash11 = `\n  float hash11(float p) {\n    p = fract(p * 0.3183099) + 0.1;\n    p *= p + 19.19;\n    return fract(p * p);\n  }\n`;\nconst proceduralHash21 = `\n  float hash21(vec2 p) {\n    p = fract(p * vec2(0.3183099, 0.3678794)) + 0.1;\n    p += dot(p, p + 19.19);\n    return fract(p.x * p.y);\n  }\n`;\nconst proceduralHash22 = `\n  vec2 hash22(vec2 p) {\n    p = fract(p * vec2(0.3183099, 0.3678794)) + 0.1;\n    p += dot(p, p.yx + 19.19);\n    return fract(vec2(p.x * p.y, p.x + p.y));\n  }\n`;\nconst textureRandomizerR = `\n  float randomR(vec2 p) {\n    vec2 uv = floor(p) / 100. + .5;\n    return texture(u_noiseTexture, fract(uv)).r;\n  }\n`;\nconst textureRandomizerGB = `\n  vec2 randomGB(vec2 p) {\n    vec2 uv = floor(p) / 100. + .5;\n    return texture(u_noiseTexture, fract(uv)).gb;\n  }\n`;\nconst colorBandingFix = `\n  color += 1. / 256. * (fract(sin(dot(.014 * gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453123) - .5);\n`;\nconst simplexNoise = `\nvec3 permute(vec3 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n    -0.577350269189626, 0.024390243902439);\n  vec2 i = floor(v + dot(v, C.yy));\n  vec2 x0 = v - i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))\n    + i.x + vec3(0.0, i1.x, 1.0));\n  vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy),\n      dot(x12.zw, x12.zw)), 0.0);\n  m = m * m;\n  m = m * m;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n  vec3 g;\n  g.x = a0.x * x0.x + h.x * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n`;\nconst fiberNoise = `\nfloat fiberRandom(vec2 p) {\n  vec2 uv = floor(p) / 100.;\n  return texture(u_noiseTexture, fract(uv)).b;\n}\n\nfloat fiberValueNoise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n  float a = fiberRandom(i);\n  float b = fiberRandom(i + vec2(1.0, 0.0));\n  float c = fiberRandom(i + vec2(0.0, 1.0));\n  float d = fiberRandom(i + vec2(1.0, 1.0));\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  float x1 = mix(a, b, u.x);\n  float x2 = mix(c, d, u.x);\n  return mix(x1, x2, u.y);\n}\n\nfloat fiberNoiseFbm(in vec2 n, vec2 seedOffset) {\n  float total = 0.0, amplitude = 1.;\n  for (int i = 0; i < 4; i++) {\n    n = rotate(n, .7);\n    total += fiberValueNoise(n + seedOffset) * amplitude;\n    n *= 2.;\n    amplitude *= 0.6;\n  }\n  return total;\n}\n\nfloat fiberNoise(vec2 uv, vec2 seedOffset) {\n  float epsilon = 0.001;\n  float n1 = fiberNoiseFbm(uv + vec2(epsilon, 0.0), seedOffset);\n  float n2 = fiberNoiseFbm(uv - vec2(epsilon, 0.0), seedOffset);\n  float n3 = fiberNoiseFbm(uv + vec2(0.0, epsilon), seedOffset);\n  float n4 = fiberNoiseFbm(uv - vec2(0.0, epsilon), seedOffset);\n  return length(vec2(n1 - n2, n3 - n4)) / (2.0 * epsilon);\n}\n`;\n\n//# sourceMappingURL=shader-utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLXV0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWUU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2ltcmFubW9oYW1tZWQvZGVzaWduLXdpdGgtY2xhdWRlL3dlYi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLXV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiAgICAgICAgICAgICAgICAgICAgUGFwZXIgU2hhZGVycyAgICAgICAgICAgICAgICAgICAgKlxuICogICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3BhcGVyLWRlc2lnbi9zaGFkZXJzICAgICAgICpcbiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuXG5jb25zdCBkZWNsYXJlUEkgPSBgXG4jZGVmaW5lIFRXT19QSSA2LjI4MzE4NTMwNzE4XG4jZGVmaW5lIFBJIDMuMTQxNTkyNjUzNTg5NzkzMjM4NDZcbmA7XG5jb25zdCByb3RhdGlvbjIgPSBgXG52ZWMyIHJvdGF0ZSh2ZWMyIHV2LCBmbG9hdCB0aCkge1xuICByZXR1cm4gbWF0Mihjb3ModGgpLCBzaW4odGgpLCAtc2luKHRoKSwgY29zKHRoKSkgKiB1djtcbn1cbmA7XG5jb25zdCBwcm9jZWR1cmFsSGFzaDExID0gYFxuICBmbG9hdCBoYXNoMTEoZmxvYXQgcCkge1xuICAgIHAgPSBmcmFjdChwICogMC4zMTgzMDk5KSArIDAuMTtcbiAgICBwICo9IHAgKyAxOS4xOTtcbiAgICByZXR1cm4gZnJhY3QocCAqIHApO1xuICB9XG5gO1xuY29uc3QgcHJvY2VkdXJhbEhhc2gyMSA9IGBcbiAgZmxvYXQgaGFzaDIxKHZlYzIgcCkge1xuICAgIHAgPSBmcmFjdChwICogdmVjMigwLjMxODMwOTksIDAuMzY3ODc5NCkpICsgMC4xO1xuICAgIHAgKz0gZG90KHAsIHAgKyAxOS4xOSk7XG4gICAgcmV0dXJuIGZyYWN0KHAueCAqIHAueSk7XG4gIH1cbmA7XG5jb25zdCBwcm9jZWR1cmFsSGFzaDIyID0gYFxuICB2ZWMyIGhhc2gyMih2ZWMyIHApIHtcbiAgICBwID0gZnJhY3QocCAqIHZlYzIoMC4zMTgzMDk5LCAwLjM2Nzg3OTQpKSArIDAuMTtcbiAgICBwICs9IGRvdChwLCBwLnl4ICsgMTkuMTkpO1xuICAgIHJldHVybiBmcmFjdCh2ZWMyKHAueCAqIHAueSwgcC54ICsgcC55KSk7XG4gIH1cbmA7XG5jb25zdCB0ZXh0dXJlUmFuZG9taXplclIgPSBgXG4gIGZsb2F0IHJhbmRvbVIodmVjMiBwKSB7XG4gICAgdmVjMiB1diA9IGZsb29yKHApIC8gMTAwLiArIC41O1xuICAgIHJldHVybiB0ZXh0dXJlKHVfbm9pc2VUZXh0dXJlLCBmcmFjdCh1dikpLnI7XG4gIH1cbmA7XG5jb25zdCB0ZXh0dXJlUmFuZG9taXplckdCID0gYFxuICB2ZWMyIHJhbmRvbUdCKHZlYzIgcCkge1xuICAgIHZlYzIgdXYgPSBmbG9vcihwKSAvIDEwMC4gKyAuNTtcbiAgICByZXR1cm4gdGV4dHVyZSh1X25vaXNlVGV4dHVyZSwgZnJhY3QodXYpKS5nYjtcbiAgfVxuYDtcbmNvbnN0IGNvbG9yQmFuZGluZ0ZpeCA9IGBcbiAgY29sb3IgKz0gMS4gLyAyNTYuICogKGZyYWN0KHNpbihkb3QoLjAxNCAqIGdsX0ZyYWdDb29yZC54eSwgdmVjMigxMi45ODk4LCA3OC4yMzMpKSkgKiA0Mzc1OC41NDUzMTIzKSAtIC41KTtcbmA7XG5jb25zdCBzaW1wbGV4Tm9pc2UgPSBgXG52ZWMzIHBlcm11dGUodmVjMyB4KSB7IHJldHVybiBtb2QoKCh4ICogMzQuMCkgKyAxLjApICogeCwgMjg5LjApOyB9XG5mbG9hdCBzbm9pc2UodmVjMiB2KSB7XG4gIGNvbnN0IHZlYzQgQyA9IHZlYzQoMC4yMTEzMjQ4NjU0MDUxODcsIDAuMzY2MDI1NDAzNzg0NDM5LFxuICAgIC0wLjU3NzM1MDI2OTE4OTYyNiwgMC4wMjQzOTAyNDM5MDI0MzkpO1xuICB2ZWMyIGkgPSBmbG9vcih2ICsgZG90KHYsIEMueXkpKTtcbiAgdmVjMiB4MCA9IHYgLSBpICsgZG90KGksIEMueHgpO1xuICB2ZWMyIGkxO1xuICBpMSA9ICh4MC54ID4geDAueSkgPyB2ZWMyKDEuMCwgMC4wKSA6IHZlYzIoMC4wLCAxLjApO1xuICB2ZWM0IHgxMiA9IHgwLnh5eHkgKyBDLnh4eno7XG4gIHgxMi54eSAtPSBpMTtcbiAgaSA9IG1vZChpLCAyODkuMCk7XG4gIHZlYzMgcCA9IHBlcm11dGUocGVybXV0ZShpLnkgKyB2ZWMzKDAuMCwgaTEueSwgMS4wKSlcbiAgICArIGkueCArIHZlYzMoMC4wLCBpMS54LCAxLjApKTtcbiAgdmVjMyBtID0gbWF4KDAuNSAtIHZlYzMoZG90KHgwLCB4MCksIGRvdCh4MTIueHksIHgxMi54eSksXG4gICAgICBkb3QoeDEyLnp3LCB4MTIuencpKSwgMC4wKTtcbiAgbSA9IG0gKiBtO1xuICBtID0gbSAqIG07XG4gIHZlYzMgeCA9IDIuMCAqIGZyYWN0KHAgKiBDLnd3dykgLSAxLjA7XG4gIHZlYzMgaCA9IGFicyh4KSAtIDAuNTtcbiAgdmVjMyBveCA9IGZsb29yKHggKyAwLjUpO1xuICB2ZWMzIGEwID0geCAtIG94O1xuICBtICo9IDEuNzkyODQyOTE0MDAxNTkgLSAwLjg1MzczNDcyMDk1MzE0ICogKGEwICogYTAgKyBoICogaCk7XG4gIHZlYzMgZztcbiAgZy54ID0gYTAueCAqIHgwLnggKyBoLnggKiB4MC55O1xuICBnLnl6ID0gYTAueXogKiB4MTIueHogKyBoLnl6ICogeDEyLnl3O1xuICByZXR1cm4gMTMwLjAgKiBkb3QobSwgZyk7XG59XG5gO1xuY29uc3QgZmliZXJOb2lzZSA9IGBcbmZsb2F0IGZpYmVyUmFuZG9tKHZlYzIgcCkge1xuICB2ZWMyIHV2ID0gZmxvb3IocCkgLyAxMDAuO1xuICByZXR1cm4gdGV4dHVyZSh1X25vaXNlVGV4dHVyZSwgZnJhY3QodXYpKS5iO1xufVxuXG5mbG9hdCBmaWJlclZhbHVlTm9pc2UodmVjMiBzdCkge1xuICB2ZWMyIGkgPSBmbG9vcihzdCk7XG4gIHZlYzIgZiA9IGZyYWN0KHN0KTtcbiAgZmxvYXQgYSA9IGZpYmVyUmFuZG9tKGkpO1xuICBmbG9hdCBiID0gZmliZXJSYW5kb20oaSArIHZlYzIoMS4wLCAwLjApKTtcbiAgZmxvYXQgYyA9IGZpYmVyUmFuZG9tKGkgKyB2ZWMyKDAuMCwgMS4wKSk7XG4gIGZsb2F0IGQgPSBmaWJlclJhbmRvbShpICsgdmVjMigxLjAsIDEuMCkpO1xuICB2ZWMyIHUgPSBmICogZiAqICgzLjAgLSAyLjAgKiBmKTtcbiAgZmxvYXQgeDEgPSBtaXgoYSwgYiwgdS54KTtcbiAgZmxvYXQgeDIgPSBtaXgoYywgZCwgdS54KTtcbiAgcmV0dXJuIG1peCh4MSwgeDIsIHUueSk7XG59XG5cbmZsb2F0IGZpYmVyTm9pc2VGYm0oaW4gdmVjMiBuLCB2ZWMyIHNlZWRPZmZzZXQpIHtcbiAgZmxvYXQgdG90YWwgPSAwLjAsIGFtcGxpdHVkZSA9IDEuO1xuICBmb3IgKGludCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIG4gPSByb3RhdGUobiwgLjcpO1xuICAgIHRvdGFsICs9IGZpYmVyVmFsdWVOb2lzZShuICsgc2VlZE9mZnNldCkgKiBhbXBsaXR1ZGU7XG4gICAgbiAqPSAyLjtcbiAgICBhbXBsaXR1ZGUgKj0gMC42O1xuICB9XG4gIHJldHVybiB0b3RhbDtcbn1cblxuZmxvYXQgZmliZXJOb2lzZSh2ZWMyIHV2LCB2ZWMyIHNlZWRPZmZzZXQpIHtcbiAgZmxvYXQgZXBzaWxvbiA9IDAuMDAxO1xuICBmbG9hdCBuMSA9IGZpYmVyTm9pc2VGYm0odXYgKyB2ZWMyKGVwc2lsb24sIDAuMCksIHNlZWRPZmZzZXQpO1xuICBmbG9hdCBuMiA9IGZpYmVyTm9pc2VGYm0odXYgLSB2ZWMyKGVwc2lsb24sIDAuMCksIHNlZWRPZmZzZXQpO1xuICBmbG9hdCBuMyA9IGZpYmVyTm9pc2VGYm0odXYgKyB2ZWMyKDAuMCwgZXBzaWxvbiksIHNlZWRPZmZzZXQpO1xuICBmbG9hdCBuNCA9IGZpYmVyTm9pc2VGYm0odXYgLSB2ZWMyKDAuMCwgZXBzaWxvbiksIHNlZWRPZmZzZXQpO1xuICByZXR1cm4gbGVuZ3RoKHZlYzIobjEgLSBuMiwgbjMgLSBuNCkpIC8gKDIuMCAqIGVwc2lsb24pO1xufVxuYDtcbmV4cG9ydCB7XG4gIGNvbG9yQmFuZGluZ0ZpeCxcbiAgZGVjbGFyZVBJLFxuICBmaWJlck5vaXNlLFxuICBwcm9jZWR1cmFsSGFzaDExLFxuICBwcm9jZWR1cmFsSGFzaDIxLFxuICBwcm9jZWR1cmFsSGFzaDIyLFxuICByb3RhdGlvbjIsXG4gIHNpbXBsZXhOb2lzZSxcbiAgdGV4dHVyZVJhbmRvbWl6ZXJHQixcbiAgdGV4dHVyZVJhbmRvbWl6ZXJSXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhZGVyLXV0aWxzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/shader-utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/shaders/mesh-gradient.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/shaders/mesh-gradient.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   meshGradientFragmentShader: () => (/* binding */ meshGradientFragmentShader),\n/* harmony export */   meshGradientMeta: () => (/* binding */ meshGradientMeta)\n/* harmony export */ });\n/* harmony import */ var _shader_sizing_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shader-sizing.js */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shader-sizing.js\");\n/* harmony import */ var _shader_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shader-utils.js */ \"(ssr)/./node_modules/@paper-design/shaders/dist/shader-utils.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\n\nconst meshGradientMeta = {\n  maxColorCount: 10\n};\nconst meshGradientFragmentShader = `#version 300 es\nprecision mediump float;\n\nuniform float u_time;\n\nuniform vec4 u_colors[${meshGradientMeta.maxColorCount}];\nuniform float u_colorsCount;\n\nuniform float u_distortion;\nuniform float u_swirl;\n\n${_shader_sizing_js__WEBPACK_IMPORTED_MODULE_0__.sizingVariablesDeclaration}\n\nout vec4 fragColor;\n\n${_shader_utils_js__WEBPACK_IMPORTED_MODULE_1__.declarePI}\n${_shader_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotation2}\n\nvec2 getPosition(int i, float t) {\n  float a = float(i) * .37;\n  float b = .6 + mod(float(i), 3.) * .3;\n  float c = .8 + mod(float(i + 1), 4.) * 0.25;\n\n  float x = sin(t * b + a);\n  float y = cos(t * c + a * 1.5);\n\n  return .5 + .5 * vec2(x, y);\n}\n\nvoid main() {\n  vec2 shape_uv = v_objectUV;\n\n  shape_uv += .5;\n\n  float t = .5 * u_time;\n\n  float radius = smoothstep(0., 1., length(shape_uv - .5));\n  float center = 1. - radius;\n  for (float i = 1.; i <= 2.; i++) {\n    shape_uv.x += u_distortion * center / i * sin(t + i * .4 * smoothstep(.0, 1., shape_uv.y)) * cos(.2 * t + i * 2.4 * smoothstep(.0, 1., shape_uv.y));\n    shape_uv.y += u_distortion * center / i * cos(t + i * 2. * smoothstep(.0, 1., shape_uv.x));\n  }\n\n  vec2 uvRotated = shape_uv;\n  uvRotated -= vec2(.5);\n  float angle = 3. * u_swirl * radius;\n  uvRotated = rotate(uvRotated, -angle);\n  uvRotated += vec2(.5);\n\n  vec3 color = vec3(0.);\n  float opacity = 0.;\n  float totalWeight = 0.;\n\n  for (int i = 0; i < ${meshGradientMeta.maxColorCount}; i++) {\n    if (i >= int(u_colorsCount)) break;\n\n    vec2 pos = getPosition(i, t);\n    vec3 colorFraction = u_colors[i].rgb * u_colors[i].a;\n    float opacityFraction = u_colors[i].a;\n\n    float dist = length(uvRotated - pos);\n\n    dist = pow(dist, 3.5);\n    float weight = 1. / (dist + 1e-3);\n    color += colorFraction * weight;\n    opacity += opacityFraction * weight;\n    totalWeight += weight;\n  }\n\n  color /= totalWeight;\n  opacity /= totalWeight;\n\n  ${_shader_utils_js__WEBPACK_IMPORTED_MODULE_1__.colorBandingFix}\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\n//# sourceMappingURL=mesh-gradient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVycy9tZXNoLWdyYWRpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaUU7QUFDVTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdCQUF3QiwrQkFBK0I7QUFDdkQ7O0FBRUE7QUFDQTs7QUFFQSxFQUFFLHlFQUEwQjs7QUFFNUI7O0FBRUEsRUFBRSx1REFBUztBQUNYLEVBQUUsdURBQVM7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsTUFBTSxpQ0FBaUM7QUFDekQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUksNkRBQWU7O0FBRW5CO0FBQ0E7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9pbXJhbm1vaGFtbWVkL2Rlc2lnbi13aXRoLWNsYXVkZS93ZWIvbm9kZV9tb2R1bGVzL0BwYXBlci1kZXNpZ24vc2hhZGVycy9kaXN0L3NoYWRlcnMvbWVzaC1ncmFkaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogICAgICAgICAgICAgICAgICAgIFBhcGVyIFNoYWRlcnMgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXBlci1kZXNpZ24vc2hhZGVycyAgICAgICAqXG4gKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKi9cblxuaW1wb3J0IHsgc2l6aW5nVmFyaWFibGVzRGVjbGFyYXRpb24gfSBmcm9tIFwiLi4vc2hhZGVyLXNpemluZy5qc1wiO1xuaW1wb3J0IHsgZGVjbGFyZVBJLCByb3RhdGlvbjIsIGNvbG9yQmFuZGluZ0ZpeCB9IGZyb20gXCIuLi9zaGFkZXItdXRpbHMuanNcIjtcbmNvbnN0IG1lc2hHcmFkaWVudE1ldGEgPSB7XG4gIG1heENvbG9yQ291bnQ6IDEwXG59O1xuY29uc3QgbWVzaEdyYWRpZW50RnJhZ21lbnRTaGFkZXIgPSBgI3ZlcnNpb24gMzAwIGVzXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcblxudW5pZm9ybSBmbG9hdCB1X3RpbWU7XG5cbnVuaWZvcm0gdmVjNCB1X2NvbG9yc1ske21lc2hHcmFkaWVudE1ldGEubWF4Q29sb3JDb3VudH1dO1xudW5pZm9ybSBmbG9hdCB1X2NvbG9yc0NvdW50O1xuXG51bmlmb3JtIGZsb2F0IHVfZGlzdG9ydGlvbjtcbnVuaWZvcm0gZmxvYXQgdV9zd2lybDtcblxuJHtzaXppbmdWYXJpYWJsZXNEZWNsYXJhdGlvbn1cblxub3V0IHZlYzQgZnJhZ0NvbG9yO1xuXG4ke2RlY2xhcmVQSX1cbiR7cm90YXRpb24yfVxuXG52ZWMyIGdldFBvc2l0aW9uKGludCBpLCBmbG9hdCB0KSB7XG4gIGZsb2F0IGEgPSBmbG9hdChpKSAqIC4zNztcbiAgZmxvYXQgYiA9IC42ICsgbW9kKGZsb2F0KGkpLCAzLikgKiAuMztcbiAgZmxvYXQgYyA9IC44ICsgbW9kKGZsb2F0KGkgKyAxKSwgNC4pICogMC4yNTtcblxuICBmbG9hdCB4ID0gc2luKHQgKiBiICsgYSk7XG4gIGZsb2F0IHkgPSBjb3ModCAqIGMgKyBhICogMS41KTtcblxuICByZXR1cm4gLjUgKyAuNSAqIHZlYzIoeCwgeSk7XG59XG5cbnZvaWQgbWFpbigpIHtcbiAgdmVjMiBzaGFwZV91diA9IHZfb2JqZWN0VVY7XG5cbiAgc2hhcGVfdXYgKz0gLjU7XG5cbiAgZmxvYXQgdCA9IC41ICogdV90aW1lO1xuXG4gIGZsb2F0IHJhZGl1cyA9IHNtb290aHN0ZXAoMC4sIDEuLCBsZW5ndGgoc2hhcGVfdXYgLSAuNSkpO1xuICBmbG9hdCBjZW50ZXIgPSAxLiAtIHJhZGl1cztcbiAgZm9yIChmbG9hdCBpID0gMS47IGkgPD0gMi47IGkrKykge1xuICAgIHNoYXBlX3V2LnggKz0gdV9kaXN0b3J0aW9uICogY2VudGVyIC8gaSAqIHNpbih0ICsgaSAqIC40ICogc21vb3Roc3RlcCguMCwgMS4sIHNoYXBlX3V2LnkpKSAqIGNvcyguMiAqIHQgKyBpICogMi40ICogc21vb3Roc3RlcCguMCwgMS4sIHNoYXBlX3V2LnkpKTtcbiAgICBzaGFwZV91di55ICs9IHVfZGlzdG9ydGlvbiAqIGNlbnRlciAvIGkgKiBjb3ModCArIGkgKiAyLiAqIHNtb290aHN0ZXAoLjAsIDEuLCBzaGFwZV91di54KSk7XG4gIH1cblxuICB2ZWMyIHV2Um90YXRlZCA9IHNoYXBlX3V2O1xuICB1dlJvdGF0ZWQgLT0gdmVjMiguNSk7XG4gIGZsb2F0IGFuZ2xlID0gMy4gKiB1X3N3aXJsICogcmFkaXVzO1xuICB1dlJvdGF0ZWQgPSByb3RhdGUodXZSb3RhdGVkLCAtYW5nbGUpO1xuICB1dlJvdGF0ZWQgKz0gdmVjMiguNSk7XG5cbiAgdmVjMyBjb2xvciA9IHZlYzMoMC4pO1xuICBmbG9hdCBvcGFjaXR5ID0gMC47XG4gIGZsb2F0IHRvdGFsV2VpZ2h0ID0gMC47XG5cbiAgZm9yIChpbnQgaSA9IDA7IGkgPCAke21lc2hHcmFkaWVudE1ldGEubWF4Q29sb3JDb3VudH07IGkrKykge1xuICAgIGlmIChpID49IGludCh1X2NvbG9yc0NvdW50KSkgYnJlYWs7XG5cbiAgICB2ZWMyIHBvcyA9IGdldFBvc2l0aW9uKGksIHQpO1xuICAgIHZlYzMgY29sb3JGcmFjdGlvbiA9IHVfY29sb3JzW2ldLnJnYiAqIHVfY29sb3JzW2ldLmE7XG4gICAgZmxvYXQgb3BhY2l0eUZyYWN0aW9uID0gdV9jb2xvcnNbaV0uYTtcblxuICAgIGZsb2F0IGRpc3QgPSBsZW5ndGgodXZSb3RhdGVkIC0gcG9zKTtcblxuICAgIGRpc3QgPSBwb3coZGlzdCwgMy41KTtcbiAgICBmbG9hdCB3ZWlnaHQgPSAxLiAvIChkaXN0ICsgMWUtMyk7XG4gICAgY29sb3IgKz0gY29sb3JGcmFjdGlvbiAqIHdlaWdodDtcbiAgICBvcGFjaXR5ICs9IG9wYWNpdHlGcmFjdGlvbiAqIHdlaWdodDtcbiAgICB0b3RhbFdlaWdodCArPSB3ZWlnaHQ7XG4gIH1cblxuICBjb2xvciAvPSB0b3RhbFdlaWdodDtcbiAgb3BhY2l0eSAvPSB0b3RhbFdlaWdodDtcblxuICAke2NvbG9yQmFuZGluZ0ZpeH1cblxuICBmcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCBvcGFjaXR5KTtcbn1cbmA7XG5leHBvcnQge1xuICBtZXNoR3JhZGllbnRGcmFnbWVudFNoYWRlcixcbiAgbWVzaEdyYWRpZW50TWV0YVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lc2gtZ3JhZGllbnQuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/shaders/mesh-gradient.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@paper-design/shaders/dist/vertex-shader.js":
/*!******************************************************************!*\
  !*** ./node_modules/@paper-design/shaders/dist/vertex-shader.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   vertexShaderSource: () => (/* binding */ vertexShaderSource)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nconst vertexShaderSource = `#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec4 a_position;\n\nuniform vec2 u_resolution;\nuniform float u_pixelRatio;\nuniform float u_imageAspectRatio;\n\nuniform float u_originX;\nuniform float u_originY;\nuniform float u_worldWidth;\nuniform float u_worldHeight;\nuniform float u_fit;\n\nuniform float u_scale;\nuniform float u_rotation;\nuniform float u_offsetX;\nuniform float u_offsetY;\n\nuniform float u_pxSize;\n\nout vec2 v_objectUV;\nout vec2 v_objectBoxSize;\nout vec2 v_objectHelperBox;\n\nout vec2 v_responsiveUV;\nout vec2 v_responsiveBoxSize;\nout vec2 v_responsiveHelperBox;\nout vec2 v_responsiveBoxGivenSize;\n\nout vec2 v_patternUV;\nout vec2 v_patternBoxSize;\nout vec2 v_patternHelperBox;\n\nout vec2 v_imageUV;\n\n// #define ADD_HELPERS\n\nvec3 getBoxSize(float boxRatio, vec2 givenBoxSize) {\n  vec2 box = vec2(0.);\n  // fit = none\n  box.x = boxRatio * min(givenBoxSize.x / boxRatio, givenBoxSize.y);\n  float noFitBoxWidth = box.x;\n  if (u_fit == 1.) { // fit = contain\n    box.x = boxRatio * min(u_resolution.x / boxRatio, u_resolution.y);\n  } else if (u_fit == 2.) { // fit = cover\n    box.x = boxRatio * max(u_resolution.x / boxRatio, u_resolution.y);\n  }\n  box.y = box.x / boxRatio;\n  return vec3(box, noFitBoxWidth);\n}\n\nvoid main() {\n  gl_Position = a_position;\n\n  vec2 uv = gl_Position.xy * .5;\n  vec2 boxOrigin = vec2(.5 - u_originX, u_originY - .5);\n  vec2 givenBoxSize = vec2(u_worldWidth, u_worldHeight);\n  givenBoxSize = max(givenBoxSize, vec2(1.)) * u_pixelRatio;\n  float r = u_rotation * 3.14159265358979323846 / 180.;\n  mat2 graphicRotation = mat2(cos(r), sin(r), -sin(r), cos(r));\n  vec2 graphicOffset = vec2(-u_offsetX, u_offsetY);\n\n\n  // ===================================================\n  // Sizing api for graphic objects with fixed ratio\n  // (currently supports only ratio = 1)\n\n  float fixedRatio = 1.;\n  vec2 fixedRatioBoxGivenSize = vec2(\n  (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n  (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n\n  v_objectBoxSize = getBoxSize(fixedRatio, fixedRatioBoxGivenSize).xy;\n  vec2 objectWorldScale = u_resolution.xy / v_objectBoxSize;\n\n  #ifdef ADD_HELPERS\n  v_objectHelperBox = uv;\n  v_objectHelperBox *= objectWorldScale;\n  v_objectHelperBox += boxOrigin * (objectWorldScale - 1.);\n  #endif\n\n  v_objectUV = uv;\n  v_objectUV *= objectWorldScale;\n  v_objectUV += boxOrigin * (objectWorldScale - 1.);\n  v_objectUV += graphicOffset;\n  v_objectUV /= u_scale;\n  v_objectUV = graphicRotation * v_objectUV;\n\n\n  // ===================================================\n\n\n  // ===================================================\n  // Sizing api for graphic objects with either givenBoxSize ratio or canvas ratio.\n  // Full-screen mode available with u_worldWidth = u_worldHeight = 0\n\n  v_responsiveBoxGivenSize = vec2(\n  (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n  (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n  float responsiveRatio = v_responsiveBoxGivenSize.x / v_responsiveBoxGivenSize.y;\n  v_responsiveBoxSize = getBoxSize(responsiveRatio, v_responsiveBoxGivenSize).xy;\n  vec2 responsiveBoxScale = u_resolution.xy / v_responsiveBoxSize;\n\n  #ifdef ADD_HELPERS\n  v_responsiveHelperBox = uv;\n  v_responsiveHelperBox *= responsiveBoxScale;\n  v_responsiveHelperBox += boxOrigin * (responsiveBoxScale - 1.);\n  #endif\n\n  v_responsiveUV = uv;\n  v_responsiveUV *= responsiveBoxScale;\n  v_responsiveUV += boxOrigin * (responsiveBoxScale - 1.);\n  v_responsiveUV += graphicOffset;\n  v_responsiveUV /= u_scale;\n  v_responsiveUV.x *= responsiveRatio;\n  v_responsiveUV = graphicRotation * v_responsiveUV;\n  v_responsiveUV.x /= responsiveRatio;\n\n  // ===================================================\n\n\n  // ===================================================\n  // Sizing api for patterns\n  // (treating graphics as a image u_worldWidth x u_worldHeight size)\n\n  float patternBoxRatio = givenBoxSize.x / givenBoxSize.y;\n  vec2 patternBoxGivenSize = vec2(\n  (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n  (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n  patternBoxRatio = patternBoxGivenSize.x / patternBoxGivenSize.y;\n\n  vec3 boxSizeData = getBoxSize(patternBoxRatio, patternBoxGivenSize);\n  v_patternBoxSize = boxSizeData.xy;\n  float patternBoxNoFitBoxWidth = boxSizeData.z;\n  vec2 patternBoxScale = u_resolution.xy / v_patternBoxSize;\n\n  #ifdef ADD_HELPERS\n  v_patternHelperBox = uv;\n  v_patternHelperBox *= patternBoxScale;\n  v_patternHelperBox += boxOrigin * (patternBoxScale - 1.);\n  #endif\n\n  v_patternUV = uv;\n  v_patternUV += graphicOffset / patternBoxScale;\n  v_patternUV += boxOrigin;\n  v_patternUV -= boxOrigin / patternBoxScale;\n  v_patternUV *= u_resolution.xy;\n  v_patternUV /= u_pixelRatio;\n  if (u_fit > 0.) {\n    v_patternUV *= (patternBoxNoFitBoxWidth / v_patternBoxSize.x);\n  }\n  v_patternUV /= u_scale;\n  v_patternUV = graphicRotation * v_patternUV;\n  v_patternUV += boxOrigin / patternBoxScale;\n  v_patternUV -= boxOrigin;\n  // x100 is a default multiplier between vertex and fragmant shaders\n  // we use it to avoid UV presision issues\n  v_patternUV *= .01;\n\n  // ===================================================\n\n\n  // ===================================================\n  // Sizing api for images\n\n  vec2 imageBoxSize;\n  if (u_fit == 1.) { // contain\n    imageBoxSize.x = min(u_resolution.x / u_imageAspectRatio, u_resolution.y) * u_imageAspectRatio;\n  } else if (u_fit == 2.) { // cover\n    imageBoxSize.x = max(u_resolution.x / u_imageAspectRatio, u_resolution.y) * u_imageAspectRatio;\n  } else {\n    imageBoxSize.x = min(10.0, 10.0 / u_imageAspectRatio * u_imageAspectRatio);\n  }\n  imageBoxSize.y = imageBoxSize.x / u_imageAspectRatio;\n  vec2 imageBoxScale = u_resolution.xy / imageBoxSize;\n\n  #ifdef ADD_HELPERS\n  vec2 imageHelperBox = uv;\n  imageHelperBox *= imageBoxScale;\n  imageHelperBox += boxOrigin * (imageBoxScale - 1.);\n  #endif\n\n  v_imageUV = uv;\n  v_imageUV *= imageBoxScale;\n  v_imageUV += boxOrigin * (imageBoxScale - 1.);\n  v_imageUV += graphicOffset;\n  v_imageUV /= u_scale;\n  v_imageUV.x *= u_imageAspectRatio;\n  v_imageUV = graphicRotation * v_imageUV;\n  v_imageUV.x /= u_imageAspectRatio;\n\n  v_imageUV += .5;\n  v_imageUV.y = 1. - v_imageUV.y;\n\n  // ===================================================\n\n}`;\n\n//# sourceMappingURL=vertex-shader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3QvdmVydGV4LXNoYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxJQUFJLHdCQUF3QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxJQUFJLHdCQUF3QjtBQUM1QjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxDQUFDO0FBR0M7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2ltcmFubW9oYW1tZWQvZGVzaWduLXdpdGgtY2xhdWRlL3dlYi9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3QvdmVydGV4LXNoYWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogICAgICAgICAgICAgICAgICAgIFBhcGVyIFNoYWRlcnMgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXBlci1kZXNpZ24vc2hhZGVycyAgICAgICAqXG4gKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKi9cblxuY29uc3QgdmVydGV4U2hhZGVyU291cmNlID0gYCN2ZXJzaW9uIDMwMCBlc1xucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG5cbmxheW91dChsb2NhdGlvbiA9IDApIGluIHZlYzQgYV9wb3NpdGlvbjtcblxudW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjtcbnVuaWZvcm0gZmxvYXQgdV9waXhlbFJhdGlvO1xudW5pZm9ybSBmbG9hdCB1X2ltYWdlQXNwZWN0UmF0aW87XG5cbnVuaWZvcm0gZmxvYXQgdV9vcmlnaW5YO1xudW5pZm9ybSBmbG9hdCB1X29yaWdpblk7XG51bmlmb3JtIGZsb2F0IHVfd29ybGRXaWR0aDtcbnVuaWZvcm0gZmxvYXQgdV93b3JsZEhlaWdodDtcbnVuaWZvcm0gZmxvYXQgdV9maXQ7XG5cbnVuaWZvcm0gZmxvYXQgdV9zY2FsZTtcbnVuaWZvcm0gZmxvYXQgdV9yb3RhdGlvbjtcbnVuaWZvcm0gZmxvYXQgdV9vZmZzZXRYO1xudW5pZm9ybSBmbG9hdCB1X29mZnNldFk7XG5cbnVuaWZvcm0gZmxvYXQgdV9weFNpemU7XG5cbm91dCB2ZWMyIHZfb2JqZWN0VVY7XG5vdXQgdmVjMiB2X29iamVjdEJveFNpemU7XG5vdXQgdmVjMiB2X29iamVjdEhlbHBlckJveDtcblxub3V0IHZlYzIgdl9yZXNwb25zaXZlVVY7XG5vdXQgdmVjMiB2X3Jlc3BvbnNpdmVCb3hTaXplO1xub3V0IHZlYzIgdl9yZXNwb25zaXZlSGVscGVyQm94O1xub3V0IHZlYzIgdl9yZXNwb25zaXZlQm94R2l2ZW5TaXplO1xuXG5vdXQgdmVjMiB2X3BhdHRlcm5VVjtcbm91dCB2ZWMyIHZfcGF0dGVybkJveFNpemU7XG5vdXQgdmVjMiB2X3BhdHRlcm5IZWxwZXJCb3g7XG5cbm91dCB2ZWMyIHZfaW1hZ2VVVjtcblxuLy8gI2RlZmluZSBBRERfSEVMUEVSU1xuXG52ZWMzIGdldEJveFNpemUoZmxvYXQgYm94UmF0aW8sIHZlYzIgZ2l2ZW5Cb3hTaXplKSB7XG4gIHZlYzIgYm94ID0gdmVjMigwLik7XG4gIC8vIGZpdCA9IG5vbmVcbiAgYm94LnggPSBib3hSYXRpbyAqIG1pbihnaXZlbkJveFNpemUueCAvIGJveFJhdGlvLCBnaXZlbkJveFNpemUueSk7XG4gIGZsb2F0IG5vRml0Qm94V2lkdGggPSBib3gueDtcbiAgaWYgKHVfZml0ID09IDEuKSB7IC8vIGZpdCA9IGNvbnRhaW5cbiAgICBib3gueCA9IGJveFJhdGlvICogbWluKHVfcmVzb2x1dGlvbi54IC8gYm94UmF0aW8sIHVfcmVzb2x1dGlvbi55KTtcbiAgfSBlbHNlIGlmICh1X2ZpdCA9PSAyLikgeyAvLyBmaXQgPSBjb3ZlclxuICAgIGJveC54ID0gYm94UmF0aW8gKiBtYXgodV9yZXNvbHV0aW9uLnggLyBib3hSYXRpbywgdV9yZXNvbHV0aW9uLnkpO1xuICB9XG4gIGJveC55ID0gYm94LnggLyBib3hSYXRpbztcbiAgcmV0dXJuIHZlYzMoYm94LCBub0ZpdEJveFdpZHRoKTtcbn1cblxudm9pZCBtYWluKCkge1xuICBnbF9Qb3NpdGlvbiA9IGFfcG9zaXRpb247XG5cbiAgdmVjMiB1diA9IGdsX1Bvc2l0aW9uLnh5ICogLjU7XG4gIHZlYzIgYm94T3JpZ2luID0gdmVjMiguNSAtIHVfb3JpZ2luWCwgdV9vcmlnaW5ZIC0gLjUpO1xuICB2ZWMyIGdpdmVuQm94U2l6ZSA9IHZlYzIodV93b3JsZFdpZHRoLCB1X3dvcmxkSGVpZ2h0KTtcbiAgZ2l2ZW5Cb3hTaXplID0gbWF4KGdpdmVuQm94U2l6ZSwgdmVjMigxLikpICogdV9waXhlbFJhdGlvO1xuICBmbG9hdCByID0gdV9yb3RhdGlvbiAqIDMuMTQxNTkyNjUzNTg5NzkzMjM4NDYgLyAxODAuO1xuICBtYXQyIGdyYXBoaWNSb3RhdGlvbiA9IG1hdDIoY29zKHIpLCBzaW4ociksIC1zaW4ociksIGNvcyhyKSk7XG4gIHZlYzIgZ3JhcGhpY09mZnNldCA9IHZlYzIoLXVfb2Zmc2V0WCwgdV9vZmZzZXRZKTtcblxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBTaXppbmcgYXBpIGZvciBncmFwaGljIG9iamVjdHMgd2l0aCBmaXhlZCByYXRpb1xuICAvLyAoY3VycmVudGx5IHN1cHBvcnRzIG9ubHkgcmF0aW8gPSAxKVxuXG4gIGZsb2F0IGZpeGVkUmF0aW8gPSAxLjtcbiAgdmVjMiBmaXhlZFJhdGlvQm94R2l2ZW5TaXplID0gdmVjMihcbiAgKHVfd29ybGRXaWR0aCA9PSAwLikgPyB1X3Jlc29sdXRpb24ueCA6IGdpdmVuQm94U2l6ZS54LFxuICAodV93b3JsZEhlaWdodCA9PSAwLikgPyB1X3Jlc29sdXRpb24ueSA6IGdpdmVuQm94U2l6ZS55XG4gICk7XG5cbiAgdl9vYmplY3RCb3hTaXplID0gZ2V0Qm94U2l6ZShmaXhlZFJhdGlvLCBmaXhlZFJhdGlvQm94R2l2ZW5TaXplKS54eTtcbiAgdmVjMiBvYmplY3RXb3JsZFNjYWxlID0gdV9yZXNvbHV0aW9uLnh5IC8gdl9vYmplY3RCb3hTaXplO1xuXG4gICNpZmRlZiBBRERfSEVMUEVSU1xuICB2X29iamVjdEhlbHBlckJveCA9IHV2O1xuICB2X29iamVjdEhlbHBlckJveCAqPSBvYmplY3RXb3JsZFNjYWxlO1xuICB2X29iamVjdEhlbHBlckJveCArPSBib3hPcmlnaW4gKiAob2JqZWN0V29ybGRTY2FsZSAtIDEuKTtcbiAgI2VuZGlmXG5cbiAgdl9vYmplY3RVViA9IHV2O1xuICB2X29iamVjdFVWICo9IG9iamVjdFdvcmxkU2NhbGU7XG4gIHZfb2JqZWN0VVYgKz0gYm94T3JpZ2luICogKG9iamVjdFdvcmxkU2NhbGUgLSAxLik7XG4gIHZfb2JqZWN0VVYgKz0gZ3JhcGhpY09mZnNldDtcbiAgdl9vYmplY3RVViAvPSB1X3NjYWxlO1xuICB2X29iamVjdFVWID0gZ3JhcGhpY1JvdGF0aW9uICogdl9vYmplY3RVVjtcblxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFNpemluZyBhcGkgZm9yIGdyYXBoaWMgb2JqZWN0cyB3aXRoIGVpdGhlciBnaXZlbkJveFNpemUgcmF0aW8gb3IgY2FudmFzIHJhdGlvLlxuICAvLyBGdWxsLXNjcmVlbiBtb2RlIGF2YWlsYWJsZSB3aXRoIHVfd29ybGRXaWR0aCA9IHVfd29ybGRIZWlnaHQgPSAwXG5cbiAgdl9yZXNwb25zaXZlQm94R2l2ZW5TaXplID0gdmVjMihcbiAgKHVfd29ybGRXaWR0aCA9PSAwLikgPyB1X3Jlc29sdXRpb24ueCA6IGdpdmVuQm94U2l6ZS54LFxuICAodV93b3JsZEhlaWdodCA9PSAwLikgPyB1X3Jlc29sdXRpb24ueSA6IGdpdmVuQm94U2l6ZS55XG4gICk7XG4gIGZsb2F0IHJlc3BvbnNpdmVSYXRpbyA9IHZfcmVzcG9uc2l2ZUJveEdpdmVuU2l6ZS54IC8gdl9yZXNwb25zaXZlQm94R2l2ZW5TaXplLnk7XG4gIHZfcmVzcG9uc2l2ZUJveFNpemUgPSBnZXRCb3hTaXplKHJlc3BvbnNpdmVSYXRpbywgdl9yZXNwb25zaXZlQm94R2l2ZW5TaXplKS54eTtcbiAgdmVjMiByZXNwb25zaXZlQm94U2NhbGUgPSB1X3Jlc29sdXRpb24ueHkgLyB2X3Jlc3BvbnNpdmVCb3hTaXplO1xuXG4gICNpZmRlZiBBRERfSEVMUEVSU1xuICB2X3Jlc3BvbnNpdmVIZWxwZXJCb3ggPSB1djtcbiAgdl9yZXNwb25zaXZlSGVscGVyQm94ICo9IHJlc3BvbnNpdmVCb3hTY2FsZTtcbiAgdl9yZXNwb25zaXZlSGVscGVyQm94ICs9IGJveE9yaWdpbiAqIChyZXNwb25zaXZlQm94U2NhbGUgLSAxLik7XG4gICNlbmRpZlxuXG4gIHZfcmVzcG9uc2l2ZVVWID0gdXY7XG4gIHZfcmVzcG9uc2l2ZVVWICo9IHJlc3BvbnNpdmVCb3hTY2FsZTtcbiAgdl9yZXNwb25zaXZlVVYgKz0gYm94T3JpZ2luICogKHJlc3BvbnNpdmVCb3hTY2FsZSAtIDEuKTtcbiAgdl9yZXNwb25zaXZlVVYgKz0gZ3JhcGhpY09mZnNldDtcbiAgdl9yZXNwb25zaXZlVVYgLz0gdV9zY2FsZTtcbiAgdl9yZXNwb25zaXZlVVYueCAqPSByZXNwb25zaXZlUmF0aW87XG4gIHZfcmVzcG9uc2l2ZVVWID0gZ3JhcGhpY1JvdGF0aW9uICogdl9yZXNwb25zaXZlVVY7XG4gIHZfcmVzcG9uc2l2ZVVWLnggLz0gcmVzcG9uc2l2ZVJhdGlvO1xuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFNpemluZyBhcGkgZm9yIHBhdHRlcm5zXG4gIC8vICh0cmVhdGluZyBncmFwaGljcyBhcyBhIGltYWdlIHVfd29ybGRXaWR0aCB4IHVfd29ybGRIZWlnaHQgc2l6ZSlcblxuICBmbG9hdCBwYXR0ZXJuQm94UmF0aW8gPSBnaXZlbkJveFNpemUueCAvIGdpdmVuQm94U2l6ZS55O1xuICB2ZWMyIHBhdHRlcm5Cb3hHaXZlblNpemUgPSB2ZWMyKFxuICAodV93b3JsZFdpZHRoID09IDAuKSA/IHVfcmVzb2x1dGlvbi54IDogZ2l2ZW5Cb3hTaXplLngsXG4gICh1X3dvcmxkSGVpZ2h0ID09IDAuKSA/IHVfcmVzb2x1dGlvbi55IDogZ2l2ZW5Cb3hTaXplLnlcbiAgKTtcbiAgcGF0dGVybkJveFJhdGlvID0gcGF0dGVybkJveEdpdmVuU2l6ZS54IC8gcGF0dGVybkJveEdpdmVuU2l6ZS55O1xuXG4gIHZlYzMgYm94U2l6ZURhdGEgPSBnZXRCb3hTaXplKHBhdHRlcm5Cb3hSYXRpbywgcGF0dGVybkJveEdpdmVuU2l6ZSk7XG4gIHZfcGF0dGVybkJveFNpemUgPSBib3hTaXplRGF0YS54eTtcbiAgZmxvYXQgcGF0dGVybkJveE5vRml0Qm94V2lkdGggPSBib3hTaXplRGF0YS56O1xuICB2ZWMyIHBhdHRlcm5Cb3hTY2FsZSA9IHVfcmVzb2x1dGlvbi54eSAvIHZfcGF0dGVybkJveFNpemU7XG5cbiAgI2lmZGVmIEFERF9IRUxQRVJTXG4gIHZfcGF0dGVybkhlbHBlckJveCA9IHV2O1xuICB2X3BhdHRlcm5IZWxwZXJCb3ggKj0gcGF0dGVybkJveFNjYWxlO1xuICB2X3BhdHRlcm5IZWxwZXJCb3ggKz0gYm94T3JpZ2luICogKHBhdHRlcm5Cb3hTY2FsZSAtIDEuKTtcbiAgI2VuZGlmXG5cbiAgdl9wYXR0ZXJuVVYgPSB1djtcbiAgdl9wYXR0ZXJuVVYgKz0gZ3JhcGhpY09mZnNldCAvIHBhdHRlcm5Cb3hTY2FsZTtcbiAgdl9wYXR0ZXJuVVYgKz0gYm94T3JpZ2luO1xuICB2X3BhdHRlcm5VViAtPSBib3hPcmlnaW4gLyBwYXR0ZXJuQm94U2NhbGU7XG4gIHZfcGF0dGVyblVWICo9IHVfcmVzb2x1dGlvbi54eTtcbiAgdl9wYXR0ZXJuVVYgLz0gdV9waXhlbFJhdGlvO1xuICBpZiAodV9maXQgPiAwLikge1xuICAgIHZfcGF0dGVyblVWICo9IChwYXR0ZXJuQm94Tm9GaXRCb3hXaWR0aCAvIHZfcGF0dGVybkJveFNpemUueCk7XG4gIH1cbiAgdl9wYXR0ZXJuVVYgLz0gdV9zY2FsZTtcbiAgdl9wYXR0ZXJuVVYgPSBncmFwaGljUm90YXRpb24gKiB2X3BhdHRlcm5VVjtcbiAgdl9wYXR0ZXJuVVYgKz0gYm94T3JpZ2luIC8gcGF0dGVybkJveFNjYWxlO1xuICB2X3BhdHRlcm5VViAtPSBib3hPcmlnaW47XG4gIC8vIHgxMDAgaXMgYSBkZWZhdWx0IG11bHRpcGxpZXIgYmV0d2VlbiB2ZXJ0ZXggYW5kIGZyYWdtYW50IHNoYWRlcnNcbiAgLy8gd2UgdXNlIGl0IHRvIGF2b2lkIFVWIHByZXNpc2lvbiBpc3N1ZXNcbiAgdl9wYXR0ZXJuVVYgKj0gLjAxO1xuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFNpemluZyBhcGkgZm9yIGltYWdlc1xuXG4gIHZlYzIgaW1hZ2VCb3hTaXplO1xuICBpZiAodV9maXQgPT0gMS4pIHsgLy8gY29udGFpblxuICAgIGltYWdlQm94U2l6ZS54ID0gbWluKHVfcmVzb2x1dGlvbi54IC8gdV9pbWFnZUFzcGVjdFJhdGlvLCB1X3Jlc29sdXRpb24ueSkgKiB1X2ltYWdlQXNwZWN0UmF0aW87XG4gIH0gZWxzZSBpZiAodV9maXQgPT0gMi4pIHsgLy8gY292ZXJcbiAgICBpbWFnZUJveFNpemUueCA9IG1heCh1X3Jlc29sdXRpb24ueCAvIHVfaW1hZ2VBc3BlY3RSYXRpbywgdV9yZXNvbHV0aW9uLnkpICogdV9pbWFnZUFzcGVjdFJhdGlvO1xuICB9IGVsc2Uge1xuICAgIGltYWdlQm94U2l6ZS54ID0gbWluKDEwLjAsIDEwLjAgLyB1X2ltYWdlQXNwZWN0UmF0aW8gKiB1X2ltYWdlQXNwZWN0UmF0aW8pO1xuICB9XG4gIGltYWdlQm94U2l6ZS55ID0gaW1hZ2VCb3hTaXplLnggLyB1X2ltYWdlQXNwZWN0UmF0aW87XG4gIHZlYzIgaW1hZ2VCb3hTY2FsZSA9IHVfcmVzb2x1dGlvbi54eSAvIGltYWdlQm94U2l6ZTtcblxuICAjaWZkZWYgQUREX0hFTFBFUlNcbiAgdmVjMiBpbWFnZUhlbHBlckJveCA9IHV2O1xuICBpbWFnZUhlbHBlckJveCAqPSBpbWFnZUJveFNjYWxlO1xuICBpbWFnZUhlbHBlckJveCArPSBib3hPcmlnaW4gKiAoaW1hZ2VCb3hTY2FsZSAtIDEuKTtcbiAgI2VuZGlmXG5cbiAgdl9pbWFnZVVWID0gdXY7XG4gIHZfaW1hZ2VVViAqPSBpbWFnZUJveFNjYWxlO1xuICB2X2ltYWdlVVYgKz0gYm94T3JpZ2luICogKGltYWdlQm94U2NhbGUgLSAxLik7XG4gIHZfaW1hZ2VVViArPSBncmFwaGljT2Zmc2V0O1xuICB2X2ltYWdlVVYgLz0gdV9zY2FsZTtcbiAgdl9pbWFnZVVWLnggKj0gdV9pbWFnZUFzcGVjdFJhdGlvO1xuICB2X2ltYWdlVVYgPSBncmFwaGljUm90YXRpb24gKiB2X2ltYWdlVVY7XG4gIHZfaW1hZ2VVVi54IC89IHVfaW1hZ2VBc3BlY3RSYXRpbztcblxuICB2X2ltYWdlVVYgKz0gLjU7XG4gIHZfaW1hZ2VVVi55ID0gMS4gLSB2X2ltYWdlVVYueTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxufWA7XG5leHBvcnQge1xuICB2ZXJ0ZXhTaGFkZXJTb3VyY2Vcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJ0ZXgtc2hhZGVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@paper-design/shaders/dist/vertex-shader.js\n");

/***/ })

};
;